Você tem razão! Peço desculpas por não ter percebido isso na alteração anterior. O problema era a forma como a borda e a linha divisória eram tratadas durante a transição, combinado com o layout em grade.

Fiz os seguintes ajustes no CSS para corrigir o comportamento visual dos cards fechados ao lado de um card aberto e garantir que apenas o card clicado mostre o estilo "aberto":

1.  **Removi a `border-top` e `margin-top: -1px` do `.card-content`.** A linha divisória agora é controlada *exclusivamente* pelo `::after` do `.card-header`.
2.  **Simplifiquei a transição do `.card-content`** para focar em `max-height`, `opacity` e `padding`.
3.  Garanti que a linha divisória (`.card-header::after`) fique visível por padrão (card fechado) e tenha `opacity: 0` apenas na classe `.expanded`.

Isso deve garantir que os cards não expandidos mantenham sua aparência "fechada" (com a linha no header visível) mesmo quando um card adjacente se expande. A organização do dashboard em grid para telas maiores foi mantida como na versão anterior.

Aqui está o código final e corrigido:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Loading...</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#0A84FF">
    <link rel="apple-touch-icon" href="icon-192x192.png">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <style>
        :root {
            --system-font: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            --primary-color: #0A84FF;
            --secondary-color: #000000;
            --card-bg: #1c1c1e;
            --input-bg: #2c2c2e;
            --text-color: #ffffff;
            --text-color-secondary: rgba(235, 235, 245, 0.6);
            --border-color: #3a3a3c;
            --shadow-color: rgba(0, 0, 0, 0.2);
            --danger-color: #FF453A;
            --success-color: #30D158;
            --placeholder-color: rgba(235, 235, 245, 0.3);
            --dialog-backdrop: rgba(0, 0, 0, 0.7);
            --progress-track-color: #38383a;
            --progress-bar-color: var(--success-color);
            --avg-line-color-1: #FF9F0A;
            --avg-line-color-2: #AF52DE;
            --avg-line-color-3: #5E5CE6;
            --font-family: var(--system-font);
            --border-radius: 10px;
            --card-padding: 18px;
            --outer-padding: 15px;
            --transition-speed: 0.3s;
            --transition-speed-fast: 0.1s;
            --content-transition: max-height 0.35s ease-out, opacity 0.25s ease-out 0.1s, padding-top 0.35s ease-out, padding-bottom 0.35s ease-out; /* Simplified transition */
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body { height: 100%; -webkit-tap-highlight-color: rgba(0,0,0,0); }
        body { font-family: var(--font-family); background-color: var(--secondary-color); color: var(--text-color); line-height: 1.5; padding: var(--outer-padding); overscroll-behavior-y: contain; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; font-size: 16px; }
        #dashboard-box { background-color: var(--card-bg); border-radius: var(--border-radius); padding: 15px var(--card-padding); margin-bottom: 20px; display: flex; justify-content: space-around; align-items: flex-start; text-align: center; gap: 15px; max-width: 700px; margin-left: auto; margin-right: auto; }
        .dashboard-item { position: relative; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; flex: 1; }
        .dashboard-item--progress { width: 90px; height: 90px; flex-shrink: 0; margin-top: 5px; position: relative; } /* Added relative position */
        .progress-ring { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: rotate(-90deg); }
        .progress-ring__circle { fill: none; stroke-width: 5; transition: stroke-dashoffset 0.5s ease-out; }
        .progress-ring__bg { stroke: var(--progress-track-color); }
        .progress-ring__fg { stroke: var(--progress-bar-color); stroke-linecap: round; }
        .dashboard-item--progress .dashboard-content { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: flex; flex-direction: column; align-items: center; width: 100%; } /* Ensure content takes width */
        #dashboard-month-percentage { font-size: 1.6em; color: var(--text-color); margin-bottom: 0; font-weight: 600;}
        .dashboard-item--progress .dashboard-label { margin-top: 2px; margin-bottom: 0; font-size: 0.65em; }
        .dashboard-label { font-size: 0.85em; color: var(--text-color-secondary); margin-bottom: 4px; display: block; }
        .dashboard-value { font-size: 1.4em; font-weight: 500; color: var(--primary-color); line-height: 1.2; margin-bottom: 5px; }
        .dashboard-value .unit { font-size: 0.6em; font-weight: 500; color: var(--text-color-secondary); margin-left: 2px; }
        #dashboard-summary { margin-top: 12px; font-size: 0.85em; color: var(--text-color-secondary); line-height: 1.35; text-align: left; width: 100%;}
        #dashboard-summary strong { color: var(--text-color); font-weight: 500; }
        #dashboard-summary span { display: block; margin-bottom: 3px;}
        #dashboard-planned-dates .dashboard-label { margin-bottom: 8px; margin-top: 15px; }
        #dashboard-plan-list { list-style: none; padding: 0; margin: 0; text-align: left; font-size: 0.8em; line-height: 1.4; color: var(--text-color-secondary); width: 100%; max-height: 60px; overflow: hidden; }
        #dashboard-plan-list li { margin-bottom: 3px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        #dashboard-plan-list li strong { color: var(--text-color); }
        #dashboard-plan-list .plan-warning { font-size: 0.9em; margin-left: 5px; opacity: 0.7; font-style: italic; }
        .plan-past-date-indicator { font-size: 0.9em; opacity: 0.7; margin-left: 5px;}
        #app { max-width: 700px; margin: 0 auto; display: flex; flex-direction: column; gap: 12px; }
        h1 { display: none; }
        .card { background-color: var(--card-bg); border-radius: var(--border-radius); overflow: hidden; transition: box-shadow var(--transition-speed) ease; }
        .card-header { display: flex; justify-content: space-between; align-items: center; padding: 15px var(--card-padding); cursor: pointer; transition: background-color var(--transition-speed-fast) ease; position: relative; }
        .card-header::after { content: ''; position: absolute; bottom: 0; left: var(--card-padding); right: var(--card-padding); height: 1px; background-color: var(--border-color); opacity: 1; transition: opacity var(--transition-speed-fast) ease; } /* Line is visible by default */
        .card.expanded .card-header::after { opacity: 0; } /* Line hidden only when expanded */
        .card-header h2 { color: var(--text-color); margin-bottom: 0; font-size: 1.15em; font-weight: 600; pointer-events: none; }
        .toggle-icon { font-size: 0.8em; font-weight: bold; transition: transform var(--transition-speed) ease; color: var(--text-color-secondary); margin-left: 10px; width: 20px; height: 20px; display: inline-flex; align-items: center; justify-content: center; pointer-events: none; }
        .card.expanded .toggle-icon { transform: rotate(180deg); }
        .card-content {
            padding: 0 var(--card-padding); /* Only horizontal padding when closed */
            max-height: 0;
            opacity: 0;
            overflow: hidden;
            /* Removed border-top and margin-top */
            transition: var(--content-transition);
         }
        .card.expanded .card-content {
            padding-top: var(--card-padding); /* Add top/bottom padding when open */
            padding-bottom: calc(var(--card-padding) + 5px);
            max-height: 1500px; /* Adjust as needed */
            opacity: 1;
            overflow: visible;
         }
        .form-group { margin-bottom: 16px; }
        label { display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-color-secondary); font-size: 0.9em; }
        input[type="date"], input[type="number"], input[type="text"], input[type="search"], textarea, select { width: 100%; padding: 11px 14px; border: 1px solid var(--border-color); border-radius: 8px; font-size: 1em; font-family: var(--font-family); transition: border-color var(--transition-speed) ease, box-shadow var(--transition-speed) ease; appearance: none; -webkit-appearance: none; -moz-appearance: none; background-color: var(--input-bg); color: var(--text-color); }
        input[type="text"].time-input { font-variant-numeric: tabular-nums; }
        input[type="search"] { padding-right: 35px; background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="rgba(235, 235, 245, 0.6)" class="bi bi-search" viewBox="0 0 16 16"><path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"/></svg>'); background-repeat: no-repeat; background-position: right 12px center; background-size: 16px 16px; }
        input[type="search"]::-webkit-search-cancel-button{ appearance: none; height: 14px; width: 14px; background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="rgba(235, 235, 245, 0.6)" class="bi bi-x-circle-fill" viewBox="0 0 16 16"><path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM5.354 4.646a.5.5 0 1 0-.708.708L7.293 8l-2.647 2.646a.5.5 0 0 0 .708.708L8 8.707l2.646 2.647a.5.5 0 0 0 .708-.708L8.707 8l2.647-2.646a.5.5 0 0 0-.708-.708L8 7.293 5.354 4.646z"/></svg>'); background-size: 14px 14px; cursor: pointer; }
        select { background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="rgba(235, 235, 245, 0.6)" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/></svg>'); background-repeat: no-repeat; background-position: right 14px center; background-size: 12px 12px; padding-right: 40px; }
        select:focus { background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="%230A84FF" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/></svg>'); }
        input[type="date"]::-webkit-calendar-picker-indicator { filter: invert(0.8); cursor: pointer; }
        input::placeholder, textarea::placeholder { color: var(--placeholder-color); opacity: 1; }
        input:focus, textarea:focus, select:focus { outline: none; border-color: var(--primary-color); box-shadow: 0 0 0 3px rgba(10, 132, 255, 0.3); }
        input[type="number"] { -moz-appearance: textfield; } input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        textarea { resize: vertical; min-height: 90px; }
        button { background-color: var(--primary-color); color: var(--text-color); border: none; padding: 11px 22px; border-radius: 8px; font-size: 1em; font-weight: 600; cursor: pointer; transition: background-color var(--transition-speed-fast) ease, transform var(--transition-speed-fast) ease, filter var(--transition-speed-fast) ease; display: inline-block; margin-right: 8px; margin-top: 10px; width: auto; transform: scale(1); filter: brightness(1); -webkit-user-select: none; user-select: none; }
        button:hover { filter: brightness(1.15); }
        button:active { transform: scale(0.95); filter: brightness(0.8); transition-duration: 0.05s; }
        button.secondary { background-color: var(--input-bg); color: var(--primary-color); border: 1px solid var(--border-color); } button.secondary:hover { background-color: #3a3a3c; filter: none; } button.secondary:active { background-color: #48484a; transform: scale(0.96); filter: brightness(1); }
        button.success { background-color: var(--success-color); color: var(--text-color); } button.success:hover { filter: brightness(1.15); } button.success:active { transform: scale(0.95); filter: brightness(0.8); }
        button.danger { background-color: var(--danger-color); color: var(--text-color); } button.danger:hover { background-color: #ff3b30; filter: brightness(1.15); } button.danger:active { background-color: #E0352D; transform: scale(0.96); filter: brightness(0.85); }
        #record-form .text-center button, #plan-form .text-center button { width: auto; margin-right: 8px; }
        #record-form .text-center button:last-child { margin-right: 0; }
        .change-date-button { background: none; border: none; color: var(--primary-color); cursor: pointer; font-size: 0.9em; padding: 5px 0; margin-left: 5px; text-align: left; width: auto; margin-right: 0; margin-top: 0; } .change-date-button:hover { text-decoration: underline; } .change-date-button:active { transform: scale(0.95); filter: brightness(0.8); }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 12px; text-align: center; margin-top: 10px;}
        .stat-item { background-color: var(--input-bg); padding: 16px 12px; border-radius: 8px; }
        .stat-value { font-size: 1.7em; font-weight: 600; color: var(--text-color); display: block; margin-bottom: 2px; }
        .stat-label { font-size: 0.85em; color: var(--text-color-secondary); }
        .progress-bar-container { background-color: var(--border-color); border-radius: 5px; overflow: hidden; height: 8px; margin-top: 8px; }
        .progress-bar { background-color: var(--progress-bar-color); height: 100%; width: 0; transition: width var(--transition-speed) ease-out; }
        #history-controls { margin-bottom: 15px; display: flex; gap: 10px; padding: 0 var(--card-padding) }
        .history-search-input { flex-grow: 1; }
        #showing-results-label { font-size: 0.85em; color: var(--text-color-secondary); margin-top: 5px; display: block; text-align: right; padding: 0 var(--card-padding) 5px var(--card-padding) ; min-height: 1.2em;}
        .data-list { list-style: none; padding: 0; max-height: 400px; overflow-y: auto; margin-top: 0; }
        .data-list li { background-color: transparent; border-bottom: 1px solid var(--border-color); padding: 14px var(--card-padding); margin: 0; display: flex; justify-content: space-between; align-items: flex-start; flex-wrap: wrap; transition: background-color var(--transition-speed-fast) ease; }
        .data-list li:last-child { border-bottom: none; }
        .data-list li:hover { background-color: rgba(255, 255, 255, 0.02); }
        .entry-details { font-size: 0.95em; flex-grow: 1; margin-right: 10px; line-height: 1.4; padding-bottom: 5px; }
        .entry-details strong { color: var(--text-color); font-weight: 500; }
        .entry-details .hours { color: var(--primary-color); font-weight: 600; margin-left: 5px; margin-right: 5px; }
        .entry-details .tag-badge { display: inline-block; background-color: var(--input-bg); color: var(--text-color-secondary); font-size: 0.75em; padding: 2px 6px; border-radius: 5px; margin-left: 8px; vertical-align: middle; }
        .entry-details .notes-preview { color: var(--text-color-secondary); font-size: 0.9em; display: block; margin-top: 5px; white-space: normal; overflow-wrap: break-word; max-height: 4.5em; overflow: hidden; }
        .entry-actions { flex-shrink: 0; align-self: center; }
        .entry-actions button, .plan-actions button { padding: 6px 10px; font-size: 0.85em; margin-left: 5px; margin-top: 0; width: auto; border-radius: 6px; }
        .plan-actions button { margin-top: 5px; }
        .entry-actions button.secondary, .plan-actions button.secondary { background-color: #3a3a3c; }
        .chart-container { position: relative; height: 280px; width: 100%; margin-top: 25px; }
        .dialog-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--dialog-backdrop); display: flex; justify-content: center; align-items: center; z-index: 1000; opacity: 0; visibility: hidden; transition: opacity var(--transition-speed) ease, visibility var(--transition-speed) ease; }
        .dialog-backdrop.visible { opacity: 1; visibility: visible; }
        .dialog-content { background-color: #2c2c2e; color: var(--text-color); padding: 25px; border-radius: 14px; box-shadow: 0 8px 30px rgba(0,0,0,0.4); text-align: center; max-width: 90%; width: 320px; transform: scale(0.95); transition: transform var(--transition-speed) ease; }
        .dialog-backdrop.visible .dialog-content { transform: scale(1); }
        .dialog-content p { margin-bottom: 25px; font-size: 1.05em; line-height: 1.5; }
        .dialog-actions button { width: calc(50% - 5px); margin-top: 0; padding: 10px; font-size: 1em;}
        .hidden { display: none !important; }
        .visually-hidden { position: absolute; width: 1px; height: 1px; margin: -1px; padding: 0; overflow: hidden; clip: rect(0, 0, 0, 0); border: 0; }
        .text-center { text-align: center; } .mt-1 { margin-top: 10px; } .mt-2 { margin-top: 20px; }

        @media (min-width: 768px) {
             body {
                padding: 25px;
                --outer-padding: 25px;
            }
            #dashboard-box {
                max-width: 1200px;
                margin-bottom: 30px;
                padding-left: calc(var(--card-padding) * 1.5);
                padding-right: calc(var(--card-padding) * 1.5);
                display: grid; /* Use grid for better control */
                grid-template-columns: 2fr 1fr; /* Text area takes more space */
                align-items: start; /* Align items to the top of the grid cell */
                gap: 25px;
                text-align: left; /* Reset text-align for the grid container */
            }
            .dashboard-item {
                 align-items: flex-start; /* Align content inside text item to start */
                 text-align: left; /* Ensure text aligns left */
                 flex: initial; /* Override flex behavior */
                 width: 100%; /* Ensure item takes full width of grid column */
            }
            .dashboard-item--progress {
                 width: 110px; /* Define specific width for the progress circle */
                 height: 110px; /* Define specific height */
                 margin-top: 0;
                 align-self: center; /* Vertically center within its grid cell */
                 justify-self: center; /* Horizontally center within its grid cell */
                 position: relative; /* Keep for absolute positioned content */
                 display: flex; /* Use flex to center inner content */
                 align-items: center; /* Center vertically */
                 justify-content: center; /* Center horizontally */
            }
             #app {
                max-width: 1200px;
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(340px, 1fr));
                gap: 20px;
             }
            .card-content {
                padding-left: calc(var(--card-padding) * 1.2);
                padding-right: calc(var(--card-padding) * 1.2);
            }
            .card.expanded .card-content {
                 padding-top: calc(var(--card-padding) * 1.2);
                 padding-bottom: calc(var(--card-padding) * 1.2 + 5px);
                 max-height: 2000px;
            }
             .chart-container {
                 height: 350px;
                 margin-top: 30px;
             }
            .data-list {
                 max-height: 500px;
            }
             #history-controls,
             #planning-list-container h3,
             .data-list li,
             .data-list .placeholder {
                 padding-left: calc(var(--card-padding) * 1.2);
                 padding-right: calc(var(--card-padding) * 1.2);
             }
             #history-controls { padding-right: 0; } /* Adjust if search input is inside */
             #showing-results-label {
                 padding-right: calc(var(--card-padding) * 1.2);
                 padding-left: calc(var(--card-padding) * 1.2);
             }
              #history-list .placeholder,
              #planning-list .placeholder { padding-top: 14px; padding-bottom: 14px; } /* Add padding to placeholders too */
              #planning-list-container h3 { padding-right: 0;} /* Reset right padding for h3 */
        }

        @media (min-width: 992px) {
            #dashboard-box {
                 grid-template-columns: 3fr 1fr; /* Give even more space to text on larger screens */
                 gap: 40px;
            }
             .dashboard-item--progress {
                width: 120px;
                height: 120px;
             }
             #dashboard-month-percentage { font-size: 1.8em;}
            .dashboard-item--progress .dashboard-label { font-size: 0.7em; }
        }

    </style>
</head>
<body>
    <div id="dashboard-box">
         <div class="dashboard-item">
             <span class="dashboard-label" data-translate-key="dashboardWeekHoursLabel">Horas nesta semana</span>
             <span id="dashboard-week-hours" class="dashboard-value">0 hours</span>
              <div id="dashboard-summary" style="margin-top: 12px;">
                 <span id="dashboard-month-total"><span data-translate-key="dashboardMonthLabel">Mês</span>: <strong>0 hours</strong></span>
                 <span id="dashboard-forecast"><span data-translate-key="dashboardForecastLabel">Meta</span>: ...</span>
             </div>
             <div class="hidden" id="dashboard-planned-dates">
                <span class="dashboard-label" style="margin-top: 15px;" data-translate-key="dashboardPlannedDatesLabel">Saídas de campo planejadas</span>
                <ul id="dashboard-plan-list">
                </ul>
             </div>
         </div>
         <div class="dashboard-item dashboard-item--progress">
            <svg viewBox="0 0 36 36" class="progress-ring">
                 <circle class="progress-ring__circle progress-ring__bg" cx="18" cy="18" r="15.9155"></circle>
                 <circle id="progress-ring-fg" class="progress-ring__circle progress-ring__fg" cx="18" cy="18" r="15.9155" stroke-dasharray="100 100" stroke-dashoffset="100"></circle>
            </svg>
            <div class="dashboard-content">
                <span id="dashboard-month-percentage" class="dashboard-value">0%</span>
                <span class="dashboard-label" data-translate-key="dashboardMonthGoalLabel">Meta Mês</span>
             </div>
         </div>
    </div>

    <div id="app">
        <div class="card expanded" id="record-card">
             <div class="card-header" role="button" tabindex="0">
                 <h2 data-translate-key="recordActivityTitle">Registrar Atividade</h2>
                 <span class="toggle-icon">▲</span>
             </div>
            <div class="card-content">
                <form id="record-form">
                    <input type="hidden" id="record-id">
                    <div class="form-group">
                        <label for="record-date" id="date-label">
                             <span data-translate-key="recordDateLabel">Data</span>: <strong id="display-date" data-translate-key="displayDateToday">Hoje</strong>
                            <button type="button" class="change-date-button" id="change-date-btn" data-translate-key="changeDateButton">(Alterar)</button>
                        </label>
                        <input type="date" id="record-date" class="hidden">
                    </div>
                     <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                         <div class="form-group">
                             <label for="record-hours" data-translate-key="recordTimeLabel">Tempo:</label>
                             <input type="text" inputmode="numeric" id="record-hours" class="time-input" required data-translate-placeholder-key="recordTimePlaceholder">
                         </div>
                        <div class="form-group">
                            <label for="record-tag" data-translate-key="recordModeLabel">Modalidade:</label>
                            <select id="record-tag">
                                <option value="Casa em casa" selected data-translate-key="recordTagOptionHouseToHouse">Casa em casa</option>
                                <option value="Carrinho" data-translate-key="recordTagOptionCart">Carrinho</option>
                                <option value="Cartas" data-translate-key="recordTagOptionLetters">Cartas</option>
                                <option value="Telefone" data-translate-key="recordTagOptionPhone">Telefone</option>
                                <option value="Outro" data-translate-key="recordTagOptionOther">Outro</option>
                            </select>
                        </div>
                     </div>
                    <div class="form-group">
                        <label for="record-notes" data-translate-key="recordNotesLabel">Notas / Observações (max 300):</label>
                        <textarea id="record-notes" rows="3" maxlength="300" data-translate-placeholder-key="recordNotesPlaceholder"></textarea>
                    </div>
                    <div class="text-center" style="margin-top: 20px;">
                        <button type="submit" id="save-record-btn" data-translate-key="saveRecordButton">Salvar Registro</button>
                    </div>
                </form>
            </div>
        </div>

        <div class="card" id="plan-card">
             <div class="card-header" role="button" tabindex="0">
                <h2 data-translate-key="planHoursTitle">Planejar Horas</h2>
                <span class="toggle-icon">▼</span>
             </div>
             <div class="card-content">
                 <form id="plan-form">
                    <input type="hidden" id="plan-id">
                    <div class="form-group">
                      <label for="plan-date" data-translate-key="planDateLabel">Data Futura:</label>
                      <input type="date" id="plan-date" required>
                    </div>
                    <div class="form-group">
                       <label for="plan-hours" data-translate-key="planHoursLabel">Horas Planejadas (HH:MM):</label>
                       <input type="text" inputmode="numeric" id="plan-hours" class="time-input" required data-translate-placeholder-key="planHoursPlaceholder">
                    </div>
                    <div class="text-center">
                      <button type="submit" id="save-plan-btn" data-translate-key="savePlanButton">Salvar Plano</button>
                      <button type="button" id="clear-plan-form-btn" class="secondary" data-translate-key="clearPlanFormButton">Limpar</button>
                    </div>
                </form>
                <div id="planning-list-container" class="mt-2">
                    <h3 style="font-size: 1em; font-weight: 600; color: var(--text-color-secondary); margin-bottom: 10px;" data-translate-key="planningListTitle">Próximos Planos (Interno):</h3>
                    <ul id="planning-list" class="data-list">
                        <li class="placeholder hidden" data-translate-key="planningListPlaceholder">Nenhum planejamento futuro.</li>
                    </ul>
                </div>
             </div>
        </div>

        <div class="card" id="stats-card">
            <div class="card-header" role="button" tabindex="0">
                <h2 data-translate-key="detailedSummaryTitle">Resumo Mensal Detalhado</h2>
                <span class="toggle-icon">▼</span>
             </div>
             <div class="card-content">
                 <div class="form-group" style="max-width: 200px; margin: 0 auto 25px auto; text-align:center;">
                   <label for="monthly-goal" data-translate-key="monthlyGoalLabel">Meta Mensal (Horas):</label>
                   <input type="number" id="monthly-goal" min="1" step="1" value="70">
                   <button id="save-goal-btn" class="mt-1 secondary" style="width:100%; font-size:0.9em; padding: 8px 10px;" data-translate-key="setGoalButton">Definir Meta</button>
                 </div>
                 <div class="stats-grid">
                    <div class="stat-item">
                        <span id="stats-month-hours" class="stat-value">0</span>
                        <span class="stat-label" data-translate-key="statsMonthHoursLabel">Horas no Mês</span>
                    </div>
                    <div class="stat-item">
                        <span id="stats-month-goal-progress" class="stat-value">0%</span>
                        <span class="stat-label" data-translate-key="statsGoalProgressLabel">Progresso Meta</span>
                        <div class="progress-bar-container"><div id="stats-month-progress-bar" class="progress-bar"></div></div>
                    </div>
                    <div class="stat-item">
                        <span id="stats-avg-hours-day" class="stat-value">0</span>
                        <span class="stat-label" data-translate-key="statsAvgHoursDayLabel">Média / Dia Ativo</span>
                    </div>
                    <div class="stat-item">
                        <span id="stats-month-days-active" class="stat-value">0</span>
                        <span class="stat-label" data-translate-key="statsMonthDaysActiveLabel">Dias Ativos</span>
                    </div>
                 </div>
             </div>
        </div>

        <div class="card" id="charts-card">
            <div class="card-header" role="button" tabindex="0">
                 <h2 data-translate-key="hoursChartTitle">Gráfico de Horas</h2>
                 <span class="toggle-icon">▼</span>
             </div>
             <div class="card-content">
                 <div class="form-group">
                    <label for="chart-month-selector" data-translate-key="viewMonthLabel">Visualizar Mês:</label>
                    <select id="chart-month-selector">
                    </select>
                 </div>
                 <div class="chart-container">
                    <canvas id="monthlyHoursChart"></canvas>
                 </div>
             </div>
        </div>

        <div class="card" id="history-card">
            <div class="card-header" role="button" tabindex="0">
                <h2 data-translate-key="historyTitle">Histórico de Registros</h2>
                <span class="toggle-icon">▼</span>
            </div>
             <div class="card-content">
                 <div id="history-controls">
                    <input type="search" id="history-search-input" class="history-search-input" data-translate-placeholder-key="historySearchPlaceholder">
                 </div>
                 <span id="showing-results-label"></span>
                 <ul id="history-list" class="data-list">
                    <li class="placeholder hidden" data-translate-key="historyNoRecordsYet">Nenhum registro encontrado.</li>
                 </ul>
            </div>
        </div>

        <div class="card" id="settings-card">
            <div class="card-header" role="button" tabindex="0">
                <h2 data-translate-key="settingsTitle">Configurações</h2>
                <span class="toggle-icon">▼</span>
            </div>
            <div class="card-content">
                <div class="text-center">
                  <button id="clear-all-data-btn" class="danger" data-translate-key="clearAllDataButton">Limpar Todos os Dados</button>
                </div>
                <p style="margin-top: 15px; font-size: 0.9em; color: var(--text-color-secondary); text-align: center; line-height: 1.4;" data-translate-key="clearDataWarning">
                 Atenção: Limpar os dados removerá permanentemente todos os seus registros, planos e meta deste navegador. Esta ação não pode ser desfeita.
                </p>
            </div>
        </div>
    </div>

    <div id="confirmation-dialog" class="dialog-backdrop">
      <div class="dialog-content">
         <p id="dialog-message" data-translate-key="dialogConfirmMessage">Você tem certeza?</p>
         <div class="dialog-actions">
            <button id="dialog-confirm-btn" class="danger" data-translate-key="dialogConfirmButton">Confirmar</button>
            <button id="dialog-cancel-btn" class="secondary" data-translate-key="dialogCancelButton">Cancelar</button>
         </div>
       </div>
    </div>

    <script>
        // --- JAVASCRIPT SEM ALTERAÇÕES ---
        // (O código Javascript completo fornecido anteriormente vai aqui)
        document.addEventListener('DOMContentLoaded', () => {

            const i18n = {
                translations: {},
                supportedLanguages: ['pt-BR', 'en'],
                defaultLanguage: 'en',
                currentLanguage: 'en',
                translationsUrl: './translations.json',

                detectLanguage() {
                    const fullBrowserLang = navigator.language || navigator.userLanguage || this.defaultLanguage;
                    const baseBrowserLang = fullBrowserLang.split('-')[0];

                    if (this.supportedLanguages.includes(fullBrowserLang)) {
                        this.currentLanguage = fullBrowserLang;
                    } else if (this.supportedLanguages.includes(baseBrowserLang)) {
                        this.currentLanguage = baseBrowserLang;
                    } else if (this.supportedLanguages.some(lang => lang.startsWith(baseBrowserLang))) {
                        this.currentLanguage = this.supportedLanguages.find(lang => lang.startsWith(baseBrowserLang));
                    } else if (this.supportedLanguages.includes(this.defaultLanguage)) {
                        this.currentLanguage = this.defaultLanguage;
                    } else if (this.supportedLanguages.length > 0) {
                        this.currentLanguage = this.supportedLanguages[0];
                    } else {
                        this.currentLanguage = this.defaultLanguage;
                    }
                    document.documentElement.lang = this.currentLanguage;
                },

                async loadTranslations() {
                    try {
                        const response = await fetch(this.translationsUrl);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}, ao buscar ${this.translationsUrl}`);
                        }
                        this.translations = await response.json();
                        this.translations[this.defaultLanguage] = this.translations[this.defaultLanguage] || {};
                        this.translations[this.currentLanguage] = this.translations[this.currentLanguage] || this.translations[this.defaultLanguage];
                    } catch (error) {
                        console.error('Error loading translations:', error);
                        this.translations[this.defaultLanguage] = this.translations[this.defaultLanguage] || {};
                        this.translations[this.currentLanguage] = this.translations[this.currentLanguage] || this.translations[this.defaultLanguage];
                        showFeedback(`Error loading translations: ${error.message}. Falling back to ${this.currentLanguage}.`, 'danger');
                    }
                },

                t(key, replacements = {}) {
                    const langTranslations = this.translations[this.currentLanguage]
                                             || this.translations[this.defaultLanguage]
                                             || {};
                    let translation = langTranslations[key] || key;

                    if (Array.isArray(translation)) {
                        return translation;
                    }

                    if (typeof translation === 'string') {
                        for (const placeholder in replacements) {
                           const regex = new RegExp(`\\{${placeholder}\\}`, 'g');
                           translation = translation.replace(regex, replacements[placeholder]);
                        }
                    } else {
                         translation = key;
                    }
                    return translation;
                },

                applyTranslationsToDOM() {
                    document.querySelectorAll('[data-translate-key]').forEach(element => {
                        const key = element.getAttribute('data-translate-key');
                        const translation = this.t(key);
                        if (typeof translation === 'string' && translation.includes('<') && translation.includes('>')) {
                            element.innerHTML = translation;
                        } else {
                            element.textContent = translation;
                        }
                    });
                    document.querySelectorAll('[data-translate-placeholder-key]').forEach(element => {
                        const key = element.getAttribute('data-translate-placeholder-key');
                        element.placeholder = this.t(key);
                    });
                    document.querySelectorAll('[data-translate-title-key]').forEach(element => {
                        const key = element.getAttribute('data-translate-title-key');
                        element.title = this.t(key);
                    });
                    document.title = this.t('appTitle');
                    document.querySelectorAll('.toggle-icon').forEach(icon => {
                         const card = icon.closest('.card');
                         const isExpanded = card ? card.classList.contains('expanded') : false;
                         icon.textContent = isExpanded ? this.t('toggleIconCollapse') : this.t('toggleIconExpand');
                     });
                    const tagSelect = document.getElementById('record-tag');
                    if(tagSelect) {
                         tagSelect.querySelectorAll('option[data-translate-key]').forEach(option => {
                             const key = option.getAttribute('data-translate-key');
                             option.textContent = this.t(key);
                         });
                         const defaultTagKey = "recordTagOptionHouseToHouse";
                         const defaultTagValue = i18n.t(defaultTagKey);
                         // Ensure default value exists before setting it
                         if ([...tagSelect.options].some(opt => opt.value === defaultTagValue)) {
                             tagSelect.value = defaultTagValue;
                         }
                    }
                }
            };

            let appElement, dashboardWeekHours, dashboardMonthPercentage, dashboardMonthTotal,
                dashboardForecast, dashboardPlannedDatesContainer, dashboardPlanList, progressRingFg,
                recordCard, recordForm, recordIdInput, recordDateInput, dateLabel, displayDate,
                changeDateBtn, recordHoursInput, recordTagSelect, recordNotesInput, saveRecordBtn,
                planCard, planForm, planIdInput, planDateInput, planHoursInput, savePlanBtn,
                clearPlanFormBtn, planningList, planningListPlaceholder, monthlyGoalInput, saveGoalBtn,
                statsMonthHours, statsMonthGoalProgress, statsMonthProgressBar, statsAvgHoursDay,
                statsMonthDaysActive, chartMonthSelector, monthlyHoursChartCtx, historyList,
                historySearchInput, historyListPlaceholder, showingResultsLabel, clearAllDataBtn,
                confirmationDialog, dialogMessage, dialogConfirmBtn, dialogCancelBtn,
                computedStyles, textColor, textMutedColor, gridColor, tooltipBgColor, primaryColor,
                avgLineColor1, avgLineColor2, avgLineColor3;

            let recordedEntries = [];
            let plannedEntries = [];
            let settings = { monthlyGoal: 70, goalHasBeenSet: false };
            let monthlyHoursChartInstance = null;
            let currentEditingId = null;
            let currentConfirmCallback = null;
            let isDateInputVisible = false;
            let deferredInstallPrompt = null;
            let progressRingRadius = 0;
            let progressRingCircumference = 0;

            const HISTORY_MONTH_LIMIT = 3;
            const NOTES_MAX_LENGTH = 300;
            const MIN_HOURS_PER_DAY_FORECAST = 1.0;
            const LOCAL_STORAGE_KEYS = {
                ENTRIES: 'pioneerTracker_entries_v5.2',
                PLANS: 'pioneerTracker_plans_v1.2',
                SETTINGS: 'pioneerTracker_settings_v1.2'
            };

            function replacePlaceholders(text, replacements) {
                let result = text;
                if(typeof text !== 'string') return text;
                for (const placeholder in replacements) {
                    const regex = new RegExp(`\\{${placeholder}\\}`, 'g');
                    result = result.replace(regex, replacements[placeholder]);
                }
                return result;
            }

            function getCurrentDateString() { const t = new Date(); return `${t.getFullYear()}-${String(t.getMonth() + 1).padStart(2, '0')}-${String(t.getDate()).padStart(2, '0')}`; }
            function formatDisplayDate(dateString) { if (!dateString || !dateString.includes('-')) return dateString; const [y, m, d] = dateString.split('-'); return `${d}/${m}/${y}`; }
            function getMonthYearString(date) { const m = String(date.getMonth() + 1).padStart(2, '0'); const y = date.getFullYear(); return `${m}/${y}`; }
            function getStartOfWeek(date = new Date()) { const d = new Date(date); const dayOfWeek = d.getDay(); const diff = d.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1); const sOW = new Date(d.setDate(diff)); sOW.setHours(0, 0, 0, 0); return `${sOW.getFullYear()}-${String(sOW.getMonth() + 1).padStart(2, '0')}-${String(sOW.getDate()).padStart(2, '0')}`; }
            function getDateMonthsAgo(months) { const d = new Date(); d.setMonth(d.getMonth() - months); d.setHours(0, 0, 0, 0); return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`; }

            function formatMonthYearExtensive(monthYearString) {
                if (!monthYearString || !monthYearString.includes('/')) return monthYearString;
                const [m, y] = monthYearString.split('/');
                const monthIndex = parseInt(m, 10) - 1;
                if (monthIndex < 0 || monthIndex > 11) return monthYearString;
                const monthNames = i18n.t('monthNames');
                if (!Array.isArray(monthNames) || monthNames.length !== 12) {
                     return `${m}/${y}`;
                }
                return `${monthNames[monthIndex]} ${y}`;
            }

            function formatHoursExtensive(hoursDecimal, short = false) {
                const zeroSuffix = short ? `0${i18n.t('hoursShortSuffix')}` : `0 ${i18n.t('hoursSuffix')}`;
                if (isNaN(hoursDecimal) || hoursDecimal < 0) return zeroSuffix;
                const totalMinutes = Math.round((hoursDecimal || 0) * 60);
                const hours = Math.floor(totalMinutes / 60);
                const minutes = totalMinutes % 60;
                if (hours === 0 && minutes === 0) return zeroSuffix;
                const hSuffixKey = short ? 'hoursShortSuffix' : (hours === 1 ? 'hoursSuffixSingular' : 'hoursSuffix');
                const mSuffixKey = short ? 'minutesShortSuffix' : (minutes === 1 ? 'minutesSuffixSingular' : 'minutesSuffix');
                const hSuffix = i18n.t(hSuffixKey);
                const mSuffix = i18n.t(mSuffixKey);
                const connector = (hours > 0 && minutes > 0 && !short) ? i18n.t('connectorAnd') : ' ';
                const formatString = i18n.t('hoursFormat');
                const replacements = { hours: hours > 0 ? hours.toString() : '', hSuffix: hours > 0 ? hSuffix : '', connector: (hours > 0 && minutes > 0) ? connector : '', minutes: minutes > 0 ? minutes.toString() : '', mSuffix: minutes > 0 ? mSuffix : '' };
                let result = replacePlaceholders(formatString, replacements);
                result = result.replace(/\s+/g, ' ').trim();
                return result || zeroSuffix;
            }

            function parseTimeInputToDecimal(timeString) {
                 if (!timeString) return 0;
                 const trimmed = String(timeString).trim();
                 if (!trimmed) return 0;
                 const colonMatch = trimmed.match(/^(\d{1,3}):(\d{1,2})$/);
                 if (colonMatch) {
                     const hours = parseInt(colonMatch[1], 10); const minutes = parseInt(colonMatch[2], 10);
                     if (!isNaN(hours) && !isNaN(minutes) && minutes >= 0 && minutes < 60 && hours >= 0) { return hours + (minutes / 60); }
                     else { return NaN; }
                 }
                 const numberMatch = trimmed.match(/^(\d+)$/);
                 if (numberMatch) {
                     const numStr = numberMatch[1]; const numVal = parseInt(numStr, 10);
                     if (isNaN(numVal)) return NaN;
                     if (numStr.length <= 2) {
                         if (numVal >= 0 && numVal < 60) { return numVal / 60; }
                         else if (numVal >= 60) { return numVal / 60; } // Allow entering minutes > 60? Seems intentional
                         else { return NaN; }
                     } else if (numStr.length >= 3 && numStr.length <= 4) {
                         const potentialHoursStr = numStr.slice(0, -2); const potentialMinutesStr = numStr.slice(-2);
                         const hours = parseInt(potentialHoursStr, 10); const minutes = parseInt(potentialMinutesStr, 10);
                         if (!isNaN(hours) && !isNaN(minutes) && minutes >= 0 && minutes < 60 && hours >= 0) { return hours + (minutes / 60); }
                         else { return NaN; }
                     } else { return NaN; }
                 }
                 return NaN;
            }
            function formatDecimalToTimeInput(decimalHours) { if (isNaN(decimalHours) || decimalHours <= 0) return ""; const totalMinutes = Math.round((decimalHours || 0) * 60); const hours = Math.floor(totalMinutes / 60); const minutes = totalMinutes % 60; return `${hours}:${String(minutes).padStart(2, '0')}`; }

            function formatRelativeDate(dateString) {
                const today = new Date(); today.setHours(0, 0, 0, 0);
                const inputDate = new Date(dateString + 'T00:00:00'); // Assume UTC to avoid timezone shifts
                if (isNaN(inputDate)) return formatDisplayDate(dateString);

                const tomorrow = new Date(today); tomorrow.setDate(today.getDate() + 1);
                const oneWeekFromToday = new Date(today); oneWeekFromToday.setDate(today.getDate() + 7);

                const weekdayNames = i18n.t('weekdayNamesShort');
                if (!Array.isArray(weekdayNames) || weekdayNames.length !== 7) { return formatDisplayDate(dateString); }

                // Use getTime() for reliable date comparisons
                if (inputDate.getTime() === today.getTime()) return i18n.t('today');
                if (inputDate.getTime() === tomorrow.getTime()) return i18n.t('tomorrow');
                if (inputDate.getTime() > tomorrow.getTime() && inputDate.getTime() <= oneWeekFromToday.getTime()) {
                     const weekday = weekdayNames[inputDate.getUTCDay()]; // Use getUTCDay for consistency
                     return i18n.t('nextWeekday', { weekday: weekday });
                }
                return formatDisplayDate(dateString);
            }

            function getDefaultTag() { return i18n.t('recordTagOptionHouseToHouse'); }

            function saveData() {
                try { localStorage.setItem(LOCAL_STORAGE_KEYS.ENTRIES, JSON.stringify(recordedEntries)); localStorage.setItem(LOCAL_STORAGE_KEYS.PLANS, JSON.stringify(plannedEntries)); localStorage.setItem(LOCAL_STORAGE_KEYS.SETTINGS, JSON.stringify(settings)); }
                catch (e) { showFeedback(i18n.t('feedbackDataSaveFailed'), 'danger'); }
            }
            function loadData() {
                try {
                    let storedEntriesRaw = localStorage.getItem(LOCAL_STORAGE_KEYS.ENTRIES);
                    if (storedEntriesRaw) {
                        try {
                           const parsedEntries = JSON.parse(storedEntriesRaw);
                           if (Array.isArray(parsedEntries)) {
                               // Ensure data integrity and limit notes length
                               recordedEntries = parsedEntries.map(e => ({
                                   id: e.id || Date.now(), // Ensure ID exists
                                   date: e.date,
                                   hours: Number(e.hours) || 0, // Ensure hours is a number
                                   tag: e.tag || '',
                                   notes: (e.notes || '').substring(0, NOTES_MAX_LENGTH)
                               })).filter(e => e.date && e.hours >= 0); // Filter invalid entries
                           } else {
                               throw new Error("Stored entries data is not an array");
                           }
                        }
                        catch (parseErr) { storedEntriesRaw = null; recordedEntries = []; localStorage.removeItem(LOCAL_STORAGE_KEYS.ENTRIES); }
                    } else { recordedEntries = []; }
                    recordedEntries.sort((a, b) => new Date(b.date + 'T00:00:00') - new Date(a.date + 'T00:00:00'));

                    const storedPlansRaw = localStorage.getItem(LOCAL_STORAGE_KEYS.PLANS);
                    if (storedPlansRaw) {
                        try {
                            const parsedPlans = JSON.parse(storedPlansRaw);
                            if (Array.isArray(parsedPlans)) {
                                plannedEntries = parsedPlans.map(p => ({
                                     id: p.id || Date.now(),
                                     date: p.date,
                                     hours: Number(p.hours || p.plannedHours) || 0 // Handle old 'plannedHours' key and ensure number
                                })).filter(p => p.date && p.hours > 0); // Filter invalid or 0-hour plans
                            } else {
                                throw new Error("Stored plans data is not an array");
                            }
                        } catch (parseErr) { plannedEntries = []; localStorage.removeItem(LOCAL_STORAGE_KEYS.PLANS); }
                    } else {
                        plannedEntries = [];
                    }
                    plannedEntries.sort((a, b) => new Date(a.date + 'T00:00:00') - new Date(b.date + 'T00:00:00'));

                    const storedSettingsRaw = localStorage.getItem(LOCAL_STORAGE_KEYS.SETTINGS);
                    let loadedSettings = storedSettingsRaw ? JSON.parse(storedSettingsRaw) : {};
                    settings = { monthlyGoal: 70, goalHasBeenSet: false, ...loadedSettings };
                    settings.monthlyGoal = Number(settings.monthlyGoal);
                    if (isNaN(settings.monthlyGoal) || settings.monthlyGoal <= 0) { settings.monthlyGoal = 70; }
                    if (typeof settings.goalHasBeenSet !== 'boolean') { settings.goalHasBeenSet = !!loadedSettings.monthlyGoal; } // Set goalHasBeenSet based on whether goal was loaded
                 } catch (err) {
                     recordedEntries = []; plannedEntries = []; settings = { monthlyGoal: 70, goalHasBeenSet: false };
                    try { localStorage.removeItem(LOCAL_STORAGE_KEYS.ENTRIES); localStorage.removeItem(LOCAL_STORAGE_KEYS.PLANS); localStorage.removeItem(LOCAL_STORAGE_KEYS.SETTINGS); } catch (e) { /* Ignore removal error */ }
                    showFeedback(i18n.t('feedbackLoadError'), 'danger');
                }
            }

            function triggerInstallPromptIfAvailable(context = 'Context not specified') {
                if (deferredInstallPrompt && settings.goalHasBeenSet) {
                     setTimeout(() => {
                        deferredInstallPrompt.prompt();
                        deferredInstallPrompt.userChoice.then((choiceResult) => { deferredInstallPrompt = null; })
                        .catch(err => { deferredInstallPrompt = null; });
                    }, 500);
                 }
             }

             function promptForMonthlyGoal() {
                 let goalSet = false;
                 while (!goalSet) {
                     const goalInput = prompt(i18n.t('feedbackGoalPrompt'), settings.monthlyGoal);
                     if (goalInput === null) { goalSet = true; if (!settings.goalHasBeenSet) { settings.goalHasBeenSet = true; saveData(); updateAllDisplays(); } }
                     else { const goalValue = parseInt(goalInput, 10); if (!isNaN(goalValue) && goalValue > 0) { settings.monthlyGoal = goalValue; settings.goalHasBeenSet = true; monthlyGoalInput.value = goalValue; saveData(); goalSet = true; updateAllDisplays(); showFeedback(i18n.t('feedbackGoalSet'), "success"); triggerInstallPromptIfAvailable('After setting initial goal'); } else { alert(i18n.t('feedbackGoalInvalid')); } }
                 }
             }

             function setDateInputVisibility(visible) {
                 isDateInputVisible = visible;
                 if (visible) { recordDateInput.classList.remove('hidden'); dateLabel.classList.add('visually-hidden'); recordDateInput.focus(); }
                 else { recordDateInput.classList.add('hidden'); dateLabel.classList.remove('visually-hidden'); const dateValue = recordDateInput.value; const isToday = !dateValue || dateValue === getCurrentDateString(); displayDate.textContent = isToday ? i18n.t('displayDateToday') : formatDisplayDate(dateValue); }
             }

             function toggleCard(cardElement) {
                 if (!cardElement) return; const isExpanded = cardElement.classList.contains('expanded'); cardElement.classList.toggle('expanded', !isExpanded); const icon = cardElement.querySelector('.toggle-icon');
                 if (icon) { icon.textContent = !isExpanded ? i18n.t('toggleIconCollapse') : i18n.t('toggleIconExpand'); }
                 // Ensure siblings don't show hover effects if needed (handled by removing :hover in CSS)
             }

             function clearRecordForm() {
                 recordForm.reset(); recordIdInput.value = ''; currentEditingId = null; recordDateInput.value = getCurrentDateString(); setDateInputVisibility(false); recordTagSelect.value = getDefaultTag(); recordNotesInput.value = ''; recordHoursInput.value = ''; saveRecordBtn.textContent = i18n.t('saveRecordButton'); saveRecordBtn.classList.remove('editing'); // Changed from 'add' to 'remove' potentially
             }

             function handleRecordSubmit(event) {
                 event.preventDefault(); const id = recordIdInput.value ? parseInt(recordIdInput.value, 10) : Date.now(); const date = (isDateInputVisible || (recordDateInput.value && recordDateInput.value !== getCurrentDateString())) ? recordDateInput.value : getCurrentDateString(); const hoursInput = recordHoursInput.value; const hours = parseTimeInputToDecimal(hoursInput); const tag = recordTagSelect.value || getDefaultTag(); const notes = recordNotesInput.value.trim().substring(0, NOTES_MAX_LENGTH);
                 if (isNaN(hours) || hours <= 0) { alert(i18n.t('feedbackTimeInvalid')); recordHoursInput.focus(); return; }
                 if (!date) { alert(i18n.t('feedbackDateInvalid')); if(!isDateInputVisible) setDateInputVisibility(true); recordDateInput.focus(); return; }
                 const newEntry = { id, date, hours, tag, notes }; const existingIndex = recordedEntries.findIndex(entry => entry.id === id);
                 if (existingIndex > -1) { recordedEntries[existingIndex] = newEntry; } else { recordedEntries.push(newEntry); }
                 recordedEntries.sort((a, b) => new Date(b.date + 'T00:00:00') - new Date(a.date + 'T00:00:00')); saveData(); clearRecordForm(); updateAllDisplays(); showFeedback(i18n.t('feedbackRecordSaved'), 'success');
             }

             function editRecordEntry(id) {
                 const entry = recordedEntries.find(e => e.id === id);
                 if (entry) { if (!recordCard.classList.contains('expanded')) { toggleCard(recordCard); } currentEditingId = id; recordIdInput.value = entry.id; recordDateInput.value = entry.date; setDateInputVisibility(entry.date !== getCurrentDateString()); recordHoursInput.value = formatDecimalToTimeInput(entry.hours); recordTagSelect.value = entry.tag || getDefaultTag(); recordNotesInput.value = entry.notes || ''; saveRecordBtn.textContent = i18n.t('updateRecordButton'); saveRecordBtn.classList.add('editing'); recordCard.scrollIntoView({ behavior: 'smooth', block: 'start' }); setTimeout(() => recordHoursInput.focus(), 300); }
             }

             function deleteRecordEntry(id) {
                 showConfirmationDialog(i18n.t('feedbackDeleteRecordConfirm'), () => { const index = recordedEntries.findIndex(e => e.id === id); if (index > -1) { recordedEntries.splice(index, 1); saveData(); updateAllDisplays(); showFeedback(i18n.t('feedbackRecordDeleted'), 'info'); if (currentEditingId === id) { clearRecordForm(); } } });
             }

             function clearPlanForm() {
                 planForm.reset(); planIdInput.value = ''; currentEditingId = null; planDateInput.value = ''; planHoursInput.value = ''; savePlanBtn.textContent = i18n.t('savePlanButton');
                 planDateInput.min = getCurrentDateString(); // Ensure minimum date is set initially
             }

             function handlePlanSubmit(event) {
                 event.preventDefault(); const id = planIdInput.value ? parseInt(planIdInput.value, 10) : Date.now(); const date = planDateInput.value; const hoursInput = planHoursInput.value; const hours = parseTimeInputToDecimal(hoursInput); const todayStr = getCurrentDateString();
                 if (!date || isNaN(hours) || hours <= 0) { alert(i18n.t('feedbackPlanInvalid')); if (!date) planDateInput.focus(); else planHoursInput.focus(); return; }
                 if (date < todayStr) { alert(i18n.t('feedbackPlanDatePast')); planDateInput.focus(); return; }
                 const newPlan = { id, date, hours }; const existingIndex = plannedEntries.findIndex(p => p.id === id);
                 if (existingIndex > -1) { plannedEntries[existingIndex] = newPlan; } else { plannedEntries.push(newPlan); }
                 plannedEntries.sort((a, b) => new Date(a.date + 'T00:00:00') - new Date(b.date + 'T00:00:00')); saveData(); clearPlanForm(); updateAllDisplays(); showFeedback(i18n.t('feedbackPlanSaved'), 'success');
             }

             function markPlanAsDone(id) {
                 const planIndex = plannedEntries.findIndex(p => p.id === id); if (planIndex === -1) { showFeedback(i18n.t('feedbackPlanNotFound'), 'danger'); return; } const plan = plannedEntries[planIndex]; const todayStr = getCurrentDateString(); const recordDate = new Date(plan.date + 'T00:00:00') < new Date(todayStr + 'T00:00:00') ? plan.date : todayStr; const newRecordEntry = { id: Date.now(), date: recordDate, hours: plan.hours, tag: getDefaultTag(), notes: i18n.t('planNoteFromPastPlan', { date: formatDisplayDate(plan.date) }) };
                 recordedEntries.push(newRecordEntry); recordedEntries.sort((a, b) => new Date(b.date + 'T00:00:00') - new Date(a.date + 'T00:00:00')); plannedEntries.splice(planIndex, 1); saveData(); updateAllDisplays(); showFeedback(i18n.t('feedbackPlanMarkedDone'), 'success');
             }

             function deletePlanEntry(id) {
                 showConfirmationDialog(i18n.t('feedbackDeletePlanConfirm'), () => { const initialLength = plannedEntries.length; plannedEntries = plannedEntries.filter(p => p.id !== id); if (plannedEntries.length < initialLength) { saveData(); updateAllDisplays(); showFeedback(i18n.t('feedbackPlanDeleted'), 'info'); if (currentEditingId === id) { clearPlanForm(); } } });
             }

             function handleGoalSave() {
                 const newGoal = parseInt(monthlyGoalInput.value, 10); if (!isNaN(newGoal) && newGoal > 0) { if(settings.monthlyGoal !== newGoal) { settings.monthlyGoal = newGoal; settings.goalHasBeenSet = true; saveData(); updateAllDisplays(); showFeedback(i18n.t('feedbackGoalUpdated'), 'success'); triggerInstallPromptIfAvailable('After updating goal in settings card'); } } else { alert(i18n.t('feedbackGoalInvalid')); monthlyGoalInput.value = settings.monthlyGoal; }
             }

             function handleClearAllData() {
                 showConfirmationDialog(i18n.t('feedbackClearAllConfirm'), () => { recordedEntries = []; plannedEntries = []; settings = { monthlyGoal: 70, goalHasBeenSet: false }; monthlyGoalInput.value = settings.monthlyGoal; saveData(); clearRecordForm(); clearPlanForm(); updateAllDisplays(); showFeedback(i18n.t('feedbackDataCleared'), 'danger'); document.querySelectorAll('.card').forEach(c => { const shouldBeExpanded = (c.id === 'record-card'); if (c.classList.contains('expanded') !== shouldBeExpanded) { toggleCard(c); } }); });
             }

             function showConfirmationDialog(message, onConfirm) {
                 dialogMessage.textContent = message; currentConfirmCallback = onConfirm; confirmationDialog.classList.add('visible'); dialogConfirmBtn.focus();
             }

             function hideConfirmationDialog() {
                 confirmationDialog.classList.remove('visible'); setTimeout(() => { currentConfirmCallback = null; }, 300);
             }

             function showFeedback(message, type = 'info') {
                 const feedbackElement = document.createElement('div'); feedbackElement.textContent = message; feedbackElement.style.position = 'fixed'; feedbackElement.style.bottom = '-50px'; feedbackElement.style.left = '50%'; feedbackElement.style.transform = 'translateX(-50%)'; feedbackElement.style.padding = '10px 20px'; feedbackElement.style.borderRadius = '8px'; feedbackElement.style.zIndex = '1100'; feedbackElement.style.boxShadow = '0 4px 15px rgba(0,0,0,0.2)'; feedbackElement.style.fontSize = '0.95em'; feedbackElement.style.textAlign = 'center'; feedbackElement.style.maxWidth = '90%'; feedbackElement.style.transition = 'opacity 0.4s ease, bottom 0.4s ease'; feedbackElement.style.opacity = '0';
                 switch (type) { case 'success': feedbackElement.style.backgroundColor = 'var(--success-color)'; feedbackElement.style.color = '#ffffff'; break; case 'danger': feedbackElement.style.backgroundColor = 'var(--danger-color)'; feedbackElement.style.color = '#ffffff'; break; case 'info': default: feedbackElement.style.backgroundColor = 'var(--primary-color)'; feedbackElement.style.color = '#ffffff'; break; } document.body.appendChild(feedbackElement);
                 setTimeout(() => { feedbackElement.style.opacity = '1'; feedbackElement.style.bottom = '20px'; }, 10);
                 setTimeout(() => { feedbackElement.style.opacity = '0'; feedbackElement.style.bottom = '-50px'; }, 3500);
                 setTimeout(() => { if (feedbackElement.parentNode) { feedbackElement.parentNode.removeChild(feedbackElement); } }, 4000);
             }

             function updateDashboard() {
                 const today = new Date(); const currentMonth = today.getMonth(); const currentYear = today.getFullYear(); const startOfWeekStr = getStartOfWeek(today); const todayStr = getCurrentDateString(); let monthHours = 0; let weekHours = 0;
                 recordedEntries.forEach(entry => { const entryDate = new Date(entry.date + 'T00:00:00'); if (entryDate.getMonth() === currentMonth && entryDate.getFullYear() === currentYear) { monthHours += entry.hours; } if (entry.date >= startOfWeekStr && entry.date <= todayStr) { weekHours += entry.hours; } });
                 dashboardWeekHours.textContent = formatHoursExtensive(weekHours);
                 const goal = settings.monthlyGoal; const percent = goal > 0 ? Math.min(100, (monthHours / goal) * 100) : 0; dashboardMonthPercentage.textContent = `${Math.round(percent)}%`; updateProgressRing(monthHours, goal);
                 dashboardMonthTotal.querySelector('strong').textContent = formatHoursExtensive(monthHours);
                 const lastDayOfMonth = new Date(currentYear, currentMonth + 1, 0).getDate(); const todayDayOfMonth = today.getDate(); const remainingDays = Math.max(0, lastDayOfMonth - todayDayOfMonth); const remainingHours = Math.max(0, goal - monthHours); let forecastText = ''; const forecastLabelSpan = `<span data-translate-key="dashboardForecastLabel">${i18n.t('dashboardForecastLabel')}</span>: `;
                 if (!settings.goalHasBeenSet) { forecastText = forecastLabelSpan + i18n.t('dashboardGoalNotSet'); } else if (remainingHours <= 0) { forecastText = forecastLabelSpan + i18n.t('dashboardGoalReached'); } else if (remainingDays <= 0 && monthHours < goal) { forecastText = forecastLabelSpan + i18n.t('dashboardGoalNotReached'); } else { let avgNeeded = remainingDays > 0 ? remainingHours / remainingDays : remainingHours; let daysToReachGoal = remainingDays; if (daysToReachGoal > 0 && avgNeeded > 0 && avgNeeded < MIN_HOURS_PER_DAY_FORECAST) { daysToReachGoal = Math.ceil(remainingHours / MIN_HOURS_PER_DAY_FORECAST); avgNeeded = MIN_HOURS_PER_DAY_FORECAST; } else if (daysToReachGoal <= 0) { avgNeeded = remainingHours; daysToReachGoal = 1; } const neededText = i18n.t('dashboardForecastNeeded', { remainingHours: formatHoursExtensive(remainingHours) }); const suggestion = i18n.t('dashboardForecastSuggestion', { avgNeeded: formatHoursExtensive(avgNeeded, true), daysUnit: daysToReachGoal === 1 ? i18n.t('day') : i18n.t('days'), daysNeeded: daysToReachGoal }); forecastText = `<span>${forecastLabelSpan}${neededText}</span><span style="display:block;margin-top:2px;">${suggestion}</span>`; } dashboardForecast.innerHTML = forecastText;
                 updateDashboardPlannedDates();
             }

            function updateProgressRing(currentValue, maxValue) {
                if(!progressRingFg) return; // Add guard clause
                const percentage = maxValue > 0 ? Math.min(100, (currentValue / maxValue) * 100) : 0;
                const currentCircumference = progressRingCircumference > 0 ? progressRingCircumference : 100; // Use calculated or fallback
                const offset = currentCircumference * (1 - percentage / 100);
                progressRingFg.style.strokeDasharray = `${currentCircumference} ${currentCircumference}`;
                progressRingFg.style.strokeDashoffset = Math.max(0, offset); // Ensure offset isn't negative
             }

             function updateDashboardPlannedDates() {
                 const today = new Date(); today.setHours(0, 0, 0, 0); const todayStr = getCurrentDateString(); const now = new Date(); const currentHour = now.getHours(); const overdueThreshold = 18; // Consider plans from today as overdue after 6 PM
                 const futurePlans = plannedEntries.filter(p => p.date >= todayStr).sort((a,b)=>new Date(a.date + 'T00:00:00')-new Date(b.date + 'T00:00:00')); // Include today
                 const pastUncompletedPlans = plannedEntries.filter(p => {
                     const planDate = new Date(p.date + 'T00:00:00');
                     const planTime = planDate.getTime();
                     const todayTime = today.getTime();
                     // Overdue if date is before today, OR if date is today AND current hour is past threshold
                     return planTime < todayTime || (planTime === todayTime && currentHour >= overdueThreshold);
                 }).sort((a, b) => new Date(a.date + 'T00:00:00') - new Date(b.date + 'T00:00:00'));

                // Combine, ensuring no duplicates if a plan is both future and overdue (shouldn't happen with logic above)
                 const displayPlans = [...futurePlans, ...pastUncompletedPlans].reduce((acc, current) => {
                    if (!acc.some(item => item.id === current.id)) {
                        acc.push(current);
                    }
                    return acc;
                 }, []).sort((a, b) => new Date(a.date + 'T00:00:00') - new Date(b.date + 'T00:00:00')).slice(0, 3); // Show max 3

                 dashboardPlanList.innerHTML = '';
                 if (displayPlans.length > 0) {
                    dashboardPlannedDatesContainer.classList.remove('hidden');
                    displayPlans.forEach(plan => {
                        const li = document.createElement('li');
                        li.dataset.id = plan.id;
                        const planDate = new Date(plan.date + 'T00:00:00');
                        const isOverdue = planDate.getTime() < today.getTime() || (planDate.getTime() === today.getTime() && currentHour >= overdueThreshold);

                        let dateDisplay = formatRelativeDate(plan.date);
                        // Make past dates clearer
                        if (planDate.getTime() < today.getTime()) {
                            dateDisplay = formatDisplayDate(plan.date); // Show full date for past plans
                        }

                        li.innerHTML = i18n.t('dashboardPlannedDateEntry', {
                            relativeDate: `<strong>${dateDisplay}</strong>`,
                            hours: formatHoursExtensive(plan.hours, true)
                        });
                        if (isOverdue) {
                            const warningSpan = document.createElement('span');
                            warningSpan.textContent = i18n.t('dashboardPlannedOverdue');
                            warningSpan.classList.add('plan-warning');
                            li.appendChild(warningSpan);
                         }
                        dashboardPlanList.appendChild(li); });
                    }
                 else { dashboardPlannedDatesContainer.classList.add('hidden'); }
             }

             function renderHistory() {
                 historyList.innerHTML = '';
                 const searchTerm = historySearchInput.value.trim().toLowerCase();
                 let results = [];
                 let resultsLabelText = '';
                 const hasSearch = searchTerm.length > 0;
                 const defaultTag = getDefaultTag();

                 if (hasSearch) {
                    results = recordedEntries.filter(entry => {
                         const entryDateFormatted = formatDisplayDate(entry.date).toLowerCase();
                         const entryDateISO = entry.date.toLowerCase();
                         const entryHoursStr = String(entry.hours || 0).replace('.', ','); // Consider locale?
                         const entryHoursRounded = Math.round(entry.hours || 0).toString();
                         const entryHoursFormatted = formatHoursExtensive(entry.hours).toLowerCase();
                         const entryTag = (entry.tag || '').toLowerCase();
                         const entryNotes = (entry.notes || '').toLowerCase();
                         return entryDateFormatted.includes(searchTerm) ||
                                entryDateISO.includes(searchTerm) ||
                                entryHoursStr.includes(searchTerm) ||
                                entryHoursRounded.includes(searchTerm) ||
                                entryHoursFormatted.includes(searchTerm) ||
                                entryTag.includes(searchTerm) ||
                                entryNotes.includes(searchTerm);
                    });
                    const searchTermText = i18n.t('historyShowingResultsTerm', { term: `"${searchTerm}"` }); // Add quotes to term
                    resultsLabelText = i18n.t('historyShowingResultsLabel', { count: results.length, searchTerm: searchTermText });
                 }
                 else {
                    const dateLimit = getDateMonthsAgo(HISTORY_MONTH_LIMIT);
                    results = recordedEntries.filter(entry => entry.date >= dateLimit);
                    if (recordedEntries.length > 0 && results.length === 0) {
                        resultsLabelText = i18n.t('historyNoRecentData', { months: HISTORY_MONTH_LIMIT });
                    } else if (recordedEntries.length > 0) {
                        resultsLabelText = i18n.t('historyShowingLastMonthsLabel', { months: HISTORY_MONTH_LIMIT });
                    } else {
                        resultsLabelText = ''; // No label if no entries ever
                    }
                 }
                 showingResultsLabel.textContent = resultsLabelText;

                 if (results.length === 0) {
                    let placeholderKey = 'historyNoRecordsYet';
                    if (recordedEntries.length > 0) { // Records exist, but no results for search/filter
                        placeholderKey = hasSearch ? 'historyPlaceholderSearch' : 'historyPlaceholderRecent';
                    }
                    historyListPlaceholder.textContent = i18n.t(placeholderKey, { months: HISTORY_MONTH_LIMIT });
                    historyListPlaceholder.classList.remove('hidden');
                 }
                 else { historyListPlaceholder.classList.add('hidden'); }

                 results.forEach(entry => {
                    const li = document.createElement('li');
                    li.dataset.id = entry.id;
                    const tagDisplay = entry.tag && entry.tag !== defaultTag ? `<span class="tag-badge">${entry.tag}</span>` : '';
                    const notesPreviewText = entry.notes ? entry.notes.replace(/\n/g, ' ') : i18n.t('historyEntryNoNotes');
                    // Using template literals for cleaner HTML structure
                    li.innerHTML = `
                        <div class="entry-details">
                            <strong>${formatDisplayDate(entry.date)}:</strong><span class="hours">${formatHoursExtensive(entry.hours)}</span>${tagDisplay}
                            <span class="notes-preview">${notesPreviewText}</span>
                        </div>
                        <div class="entry-actions">
                            <button class="edit-btn secondary" data-translate-key="historyEditButton">${i18n.t('historyEditButton')}</button>
                            <button class="delete-btn danger" data-translate-key="historyDeleteButton">${i18n.t('historyDeleteButton')}</button>
                        </div>`;
                    li.querySelector('.edit-btn').addEventListener('click', (e) => { e.stopPropagation(); editRecordEntry(entry.id); });
                    li.querySelector('.delete-btn').addEventListener('click', (e) => { e.stopPropagation(); deleteRecordEntry(entry.id); });
                    historyList.appendChild(li);
                });
             }

             function renderPlanning() {
                 planningList.innerHTML = ''; const todayStr = getCurrentDateString();
                 // Ensure plans are sorted correctly by date primarily, then ID as fallback if dates are same
                 const allPlansSorted = [...plannedEntries].sort((a, b) => {
                     const dateA = new Date(a.date + 'T00:00:00');
                     const dateB = new Date(b.date + 'T00:00:00');
                     if(dateA < dateB) return -1;
                     if(dateA > dateB) return 1;
                     return a.id - b.id; // Secondary sort by ID for stability
                 });

                 if (allPlansSorted.length === 0) {
                     planningListPlaceholder.textContent = i18n.t('planningListPlaceholder'); // Changed key
                     planningListPlaceholder.classList.remove('hidden'); return;
                 }
                 planningListPlaceholder.classList.add('hidden');

                 allPlansSorted.forEach(plan => {
                    const li = document.createElement('li');
                    li.dataset.id = plan.id;
                    const hoursDisplay = formatHoursExtensive(plan.hours, true); // Use short format
                    const isPastPlan = plan.date < todayStr;
                    let dateDisplay = formatRelativeDate(plan.date);
                    if (isPastPlan) {
                         dateDisplay = formatDisplayDate(plan.date); // Show full date for past plans
                    }

                    li.innerHTML = `
                        <div class="entry-details">
                             <strong>${dateDisplay}:</strong><span class="hours">${hoursDisplay}</span> ${isPastPlan ? `<span class="plan-past-date-indicator">${i18n.t('planningEntryPastDate')}</span>` : ''}
                         </div>
                         <div class="plan-actions">
                             <button class="done-plan-btn success" data-translate-key="planningDoneButton">${i18n.t('planningDoneButton')}</button>
                             <button class="delete-plan-btn danger" data-translate-key="planningDeleteButton">${i18n.t('planningDeleteButton')}</button>
                         </div>`;
                    li.querySelector('.done-plan-btn').addEventListener('click', (e) => { e.stopPropagation(); markPlanAsDone(plan.id); });
                    li.querySelector('.delete-plan-btn').addEventListener('click', (e) => { e.stopPropagation(); deletePlanEntry(plan.id); });
                    planningList.appendChild(li);
                });
             }

             function updateStatistics() {
                 const currentMonth = new Date().getMonth(); const currentYear = new Date().getFullYear(); const entriesThisMonth = recordedEntries.filter(entry => { const entryDate = new Date(entry.date + 'T00:00:00'); return entryDate.getMonth() === currentMonth && entryDate.getFullYear() === currentYear; }); let totalHoursThisMonth = 0; const activeDaysThisMonth = new Set(); entriesThisMonth.forEach(entry => { totalHoursThisMonth += entry.hours; activeDaysThisMonth.add(entry.date); }); const goal = settings.monthlyGoal; const progressPercentage = settings.goalHasBeenSet && goal > 0 ? Math.min(Math.round((totalHoursThisMonth / goal) * 100), 100) : 0; const averageHoursPerActiveDay = activeDaysThisMonth.size > 0 ? (totalHoursThisMonth / activeDaysThisMonth.size) : 0; const daysActiveCount = activeDaysThisMonth.size;
                 statsMonthHours.textContent = formatHoursExtensive(totalHoursThisMonth); statsMonthGoalProgress.textContent = settings.goalHasBeenSet ? `${progressPercentage}%` : '--%'; statsMonthProgressBar.style.width = `${progressPercentage}%`; statsAvgHoursDay.textContent = formatHoursExtensive(averageHoursPerActiveDay, true); // Use short format for average
                 statsMonthDaysActive.textContent = daysActiveCount;
             }

             function populateMonthSelector() {
                 const availableMonths = new Set(); recordedEntries.forEach(e => availableMonths.add(getMonthYearString(new Date(e.date + 'T00:00:00')))); const sortedMonths = Array.from(availableMonths).sort((a, b) => { const [mA, yA] = a.split('/'); const [mB, yB] = b.split('/'); return new Date(yB, mB - 1) - new Date(yA, mA - 1); }); const oldSelectedValue = chartMonthSelector.value; chartMonthSelector.innerHTML = '';
                 if (sortedMonths.length === 0) { const option = document.createElement('option'); option.value = ''; option.textContent = i18n.t('chartNoData'); chartMonthSelector.appendChild(option); chartMonthSelector.disabled = true; return; }
                 chartMonthSelector.disabled = false; const currentMonthYearValue = getMonthYearString(new Date()); const currentMonthYearFormatted = formatMonthYearExtensive(currentMonthYearValue); let hasCurrentMonth = sortedMonths.includes(currentMonthYearValue); let didSelectOld = false;
                 sortedMonths.forEach(monthYearValue => { const option = document.createElement('option'); option.value = monthYearValue; option.textContent = formatMonthYearExtensive(monthYearValue); if (monthYearValue === oldSelectedValue) { option.selected = true; didSelectOld = true; } else if (monthYearValue === currentMonthYearValue && !didSelectOld && !oldSelectedValue) { option.selected = true; } chartMonthSelector.appendChild(option); }); // Select current only if no old selection persists
                 if (!hasCurrentMonth) { const option = document.createElement('option'); option.value = currentMonthYearValue; option.textContent = `${currentMonthYearFormatted} (${i18n.t('chartCurrentMonthSuffix')})`; chartMonthSelector.insertBefore(option, chartMonthSelector.firstChild); if (!didSelectOld && !oldSelectedValue) option.selected = true; } // Add current month if missing and select if appropriate
                 if (!chartMonthSelector.value && chartMonthSelector.options.length > 0) { chartMonthSelector.options[0].selected = true; } // Fallback selection
             }

            function getAveragesForChart(year, monthIndex) {
                 const entriesThisYear = recordedEntries.filter(e => new Date(e.date + 'T00:00:00').getFullYear() === year);
                 const entriesThisMonth = entriesThisYear.filter(e => new Date(e.date + 'T00:00:00').getMonth() === monthIndex);
                 let totalHoursMonth = 0; const activeDaysMonth = new Set(); entriesThisMonth.forEach(e => { totalHoursMonth += e.hours; activeDaysMonth.add(e.date); });
                 let totalHoursYear = 0; const monthsWithActivityYear = new Set(); const dailyHoursYear = {}; // For more accurate yearly averages if needed
                 entriesThisYear.forEach(e => { totalHoursYear += e.hours; monthsWithActivityYear.add(getMonthYearString(new Date(e.date + 'T00:00:00'))); /* could track daily here too */});
                 const daysInMonth = new Date(year, monthIndex + 1, 0).getDate();

                 return {
                    avgDaily: activeDaysMonth.size > 0 ? totalHoursMonth / activeDaysMonth.size : 0,
                    avgWeekly: totalHoursMonth > 0 ? (totalHoursMonth / daysInMonth) * 7 : 0, // Weekly avg for the specific month
                    avgMonthly: monthsWithActivityYear.size > 0 ? totalHoursYear / monthsWithActivityYear.size : 0 // Overall monthly avg for the year
                 };
             }

             function renderCharts(selectedMonthYearValue) {
                 const chartContainer = monthlyHoursChartCtx.canvas.parentElement;
                 if (!selectedMonthYearValue) {
                    if (monthlyHoursChartInstance) monthlyHoursChartInstance.destroy(); monthlyHoursChartInstance = null;
                    chartContainer.innerHTML = `<canvas id="monthlyHoursChart"></canvas><div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--text-color-secondary); font-size: 0.9em;">${i18n.t('feedbackChartSelectMonth')}</div>`;
                    monthlyHoursChartCtx = document.getElementById('monthlyHoursChart').getContext('2d'); // Re-get context
                    return;
                 }
                 try {
                     const [selectedMonth, selectedYear] = selectedMonthYearValue.split('/').map(Number); const monthIndex = selectedMonth - 1; const year = selectedYear; const entriesSelectedMonth = recordedEntries.filter(e => { const d=new Date(e.date+'T00:00:00'); return d.getMonth()===monthIndex && d.getFullYear()===year; });
                     if(entriesSelectedMonth.length === 0){ // Handle month with no data explicitly
                          if (monthlyHoursChartInstance) monthlyHoursChartInstance.destroy(); monthlyHoursChartInstance = null;
                         chartContainer.innerHTML = `<canvas id="monthlyHoursChart"></canvas><div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--text-color-secondary); font-size: 0.9em;">${i18n.t('feedbackChartNoDataMonth')}</div>`;
                         monthlyHoursChartCtx = document.getElementById('monthlyHoursChart').getContext('2d');
                         return;
                     }

                     // Restore canvas if placeholder text was added
                     if (!document.getElementById('monthlyHoursChart')) {
                         chartContainer.innerHTML = `<canvas id="monthlyHoursChart"></canvas>`;
                         monthlyHoursChartCtx = document.getElementById('monthlyHoursChart').getContext('2d');
                     }


                     const selectedMonthYearFormatted = formatMonthYearExtensive(selectedMonthYearValue);
                     const daysInSelectedMonth = new Date(year, monthIndex + 1, 0).getDate(); const dailyHoursData = Array(daysInSelectedMonth).fill(0); entriesSelectedMonth.forEach(e => { dailyHoursData[new Date(e.date+'T00:00:00').getDate()-1] += e.hours; }); const chartLabels = Array.from({ length: daysInSelectedMonth }, (_, i) => i + 1); const averages = getAveragesForChart(year, monthIndex);
                     const annotations = {}; let pluginOptions = {};

                     // Safely check for ChartAnnotation plugin
                     if (typeof ChartAnnotation !== 'undefined' && ChartAnnotation) {
                        const labelFont = { size: 10 };
                        if (averages.avgDaily > 0) annotations.avgDay = { type: 'line', scaleID: 'y', value: averages.avgDaily, borderColor: avgLineColor1, borderWidth: 1, borderDash: [6, 6], label: { content: i18n.t('chartAvgDailyLabel', {value:formatHoursExtensive(averages.avgDaily,true)}), display: true, position: 'end', color: avgLineColor1, backgroundColor: tooltipBgColor, font: labelFont, padding: 3, yAdjust: -8 }};
                        if (averages.avgWeekly > 0) annotations.avgWeek = { type: 'line', scaleID: 'y', value: averages.avgWeekly, borderColor: avgLineColor2, borderWidth: 1, borderDash: [10, 10], label: { content: i18n.t('chartAvgWeeklyLabel', {value:formatHoursExtensive(averages.avgWeekly,true)}), display: true, position: 'start', color: avgLineColor2, backgroundColor: tooltipBgColor, font: labelFont, padding: 3, yAdjust: -8 }}; // Position start
                        if (averages.avgMonthly > 0) annotations.avgMonth = { type: 'line', scaleID: 'y', value: averages.avgMonthly, borderColor: avgLineColor3, borderWidth: 1, borderDash: [2, 2], label: { content: i18n.t('chartAvgMonthlyLabel', {value:formatHoursExtensive(averages.avgMonthly,true)}), display: true, position: 'end', color: avgLineColor3, backgroundColor: tooltipBgColor, font: labelFont, padding: 3, yAdjust: 8 }};
                         pluginOptions.annotation = { annotations: annotations };
                     }

                     if (monthlyHoursChartInstance) monthlyHoursChartInstance.destroy();
                     monthlyHoursChartInstance = new Chart(monthlyHoursChartCtx, { type: 'bar', data: { labels: chartLabels, datasets: [{ label: i18n.t('chartDailyHoursLabel'), data: dailyHoursData, backgroundColor: primaryColor, borderColor: primaryColor, borderWidth: 0, borderRadius: 4 }] },
                        options: { responsive: true, maintainAspectRatio: false,
                         scales: { y: { beginAtZero: true, title:{display:false}, ticks:{color: textMutedColor, padding: 8, callback: v=>formatHoursExtensive(v, true)}, grid: {color:gridColor, drawBorder: false}, suggestedMax: Math.max(8, Math.max(...dailyHoursData) * 1.1) }, // Ensure scale shows reasonable height
                                  x: { title:{display:false}, ticks:{color:textMutedColor, padding: 5}, grid:{display: false}}},
                         plugins: { ...pluginOptions, title: { display: true, text: selectedMonthYearFormatted, color: textColor, font: { size: 14, weight: 'normal' }, padding: { bottom: 15 }},
                                     tooltip: { backgroundColor: tooltipBgColor, titleColor: textColor, bodyColor: textColor, displayColors: false, padding: 8, cornerRadius: 6, callbacks: { label: ctx => i18n.t('chartTooltipLabel', {day: ctx.label, hours: formatHoursExtensive(ctx.parsed.y)})}}, legend: { display: false } } } });
                 } catch (error) {
                     console.error("Chart rendering error:", error);
                      if (monthlyHoursChartInstance) monthlyHoursChartInstance.destroy(); monthlyHoursChartInstance = null;
                      chartContainer.innerHTML = `<canvas id="monthlyHoursChart"></canvas><div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--text-color-secondary); font-size: 0.9em;">${i18n.t('feedbackChartRenderError')}</div>`;
                      monthlyHoursChartCtx = document.getElementById('monthlyHoursChart').getContext('2d');
                 }
             }

             function updateAllDisplays() {
                 updateDashboard(); updateStatistics(); populateMonthSelector(); renderHistory(); renderPlanning();
                 const selectedMonthValue = chartMonthSelector.value;
                 renderCharts(selectedMonthValue || (chartMonthSelector.options.length > 0 ? chartMonthSelector.options[0].value : null)); // Render selected or first option if available

                 if (recordIdInput.value) { saveRecordBtn.textContent = i18n.t('updateRecordButton'); } else { saveRecordBtn.textContent = i18n.t('saveRecordButton'); }
             }

             function formatTimeInputOnType(event) {
                  const input = event.target; let value = input.value; let cursorPos = input.selectionStart; let numericValue = value.replace(/[^\d]/g, ''); let formattedValue = ''; let newCursorPos = cursorPos; numericValue = numericValue.substring(0, 4);
                  if (numericValue.length === 0) { formattedValue = ''; } else if (numericValue.length <= 2) { formattedValue = `0:${numericValue.padStart(2, '0')}`; newCursorPos = formattedValue.length; } // Assume minutes if 1 or 2 digits
                  else { const hoursPart = numericValue.slice(0, -2); const minutesPart = numericValue.slice(-2); formattedValue = `${hoursPart}:${minutesPart}`; if (value.indexOf(':') === -1 && formattedValue.indexOf(':') !== -1) { if (cursorPos >= formattedValue.indexOf(':')) { newCursorPos = cursorPos + 1; } } }
                  if (input.value !== formattedValue) { input.value = formattedValue; input.setSelectionRange(newCursorPos, newCursorPos); } // Use direct assignment, requestAnimationFrame caused issues before
             }
             function validateTimeInputOnBlur(event) {
                 const input = event.target; const decimalValue = parseTimeInputToDecimal(input.value); if (!isNaN(decimalValue) && decimalValue > 0) { input.value = formatDecimalToTimeInput(decimalValue); } else if (input.value.trim() !== '') { input.value = ''; } // Clear if invalid
             }
             function validateNotesInput(event) {
                 const input = event.target; if (input.value.length > NOTES_MAX_LENGTH) { input.value = input.value.substring(0, NOTES_MAX_LENGTH); showFeedback(i18n.t('feedbackNotesLengthLimit', { maxLength: NOTES_MAX_LENGTH }), 'info'); }
             }
             function registerServiceWorker() {
                 if ('serviceWorker' in navigator) { navigator.serviceWorker.register('./service-worker.js').then((reg) => {}).catch((error) => {}); }
             }

             async function init() {
                 i18n.detectLanguage();
                 await i18n.loadTranslations();
                 appElement=document.getElementById('app');dashboardWeekHours=document.getElementById('dashboard-week-hours');dashboardMonthPercentage=document.getElementById('dashboard-month-percentage');dashboardMonthTotal=document.getElementById('dashboard-month-total');dashboardForecast=document.getElementById('dashboard-forecast');dashboardPlannedDatesContainer=document.getElementById('dashboard-planned-dates');dashboardPlanList=document.getElementById('dashboard-plan-list');progressRingFg=document.getElementById('progress-ring-fg');recordCard=document.getElementById('record-card');recordForm=document.getElementById('record-form');recordIdInput=document.getElementById('record-id');recordDateInput=document.getElementById('record-date');dateLabel=document.getElementById('date-label');displayDate=document.getElementById('display-date');changeDateBtn=document.getElementById('change-date-btn');recordHoursInput=document.getElementById('record-hours');recordTagSelect=document.getElementById('record-tag');recordNotesInput=document.getElementById('record-notes');saveRecordBtn=document.getElementById('save-record-btn');planCard=document.getElementById('plan-card');planForm=document.getElementById('plan-form');planIdInput=document.getElementById('plan-id');planDateInput=document.getElementById('plan-date');planHoursInput=document.getElementById('plan-hours');savePlanBtn=document.getElementById('save-plan-btn');clearPlanFormBtn=document.getElementById('clear-plan-form-btn');planningList=document.getElementById('planning-list');planningListPlaceholder=planningList.querySelector('.placeholder');monthlyGoalInput=document.getElementById('monthly-goal');saveGoalBtn=document.getElementById('save-goal-btn');statsMonthHours=document.getElementById('stats-month-hours');statsMonthGoalProgress=document.getElementById('stats-month-goal-progress');statsMonthProgressBar=document.getElementById('stats-month-progress-bar');statsAvgHoursDay=document.getElementById('stats-avg-hours-day');statsMonthDaysActive=document.getElementById('stats-month-days-active');chartMonthSelector=document.getElementById('chart-month-selector');monthlyHoursChartCtx=document.getElementById('monthlyHoursChart').getContext('2d');historyList=document.getElementById('history-list');historySearchInput=document.getElementById('history-search-input');historyListPlaceholder=historyList.querySelector('.placeholder');showingResultsLabel=document.getElementById('showing-results-label');clearAllDataBtn=document.getElementById('clear-all-data-btn');confirmationDialog=document.getElementById('confirmation-dialog');dialogMessage=document.getElementById('dialog-message');dialogConfirmBtn=document.getElementById('dialog-confirm-btn');dialogCancelBtn=document.getElementById('dialog-cancel-btn'); computedStyles = getComputedStyle(document.body); textColor = computedStyles.getPropertyValue('--text-color').trim(); textMutedColor = computedStyles.getPropertyValue('--text-color-secondary').trim(); gridColor = computedStyles.getPropertyValue('--border-color').trim(); tooltipBgColor = computedStyles.getPropertyValue('--card-bg').trim(); primaryColor = computedStyles.getPropertyValue('--primary-color').trim(); avgLineColor1 = computedStyles.getPropertyValue('--avg-line-color-1').trim(); avgLineColor2 = computedStyles.getPropertyValue('--avg-line-color-2').trim(); avgLineColor3 = computedStyles.getPropertyValue('--avg-line-color-3').trim();
                 if (progressRingFg && progressRingFg.r && progressRingFg.r.baseVal) { progressRingRadius = progressRingFg.r.baseVal.value; if (progressRingRadius > 0) { progressRingCircumference = 2 * Math.PI * progressRingRadius; } else { progressRingCircumference = 100; } } else { progressRingCircumference = 100; }
                 i18n.applyTranslationsToDOM();
                 loadData();
                 const oldDefaultTag = "Casa em casa"; const currentDefaultTag = getDefaultTag(); if (oldDefaultTag !== currentDefaultTag && currentDefaultTag) { let tagsUpdated = false; recordedEntries.forEach(entry => { if (entry.tag === oldDefaultTag || !entry.tag) { entry.tag = currentDefaultTag; tagsUpdated = true; } }); if (tagsUpdated) { saveData(); } } monthlyGoalInput.value = settings.monthlyGoal;
                 // Ensure ChartAnnotation plugin is available globally before registering
                 if (typeof ChartAnnotation !== 'undefined' && ChartAnnotation) { try { Chart.register(ChartAnnotation); } catch (e) { console.error("Error registering ChartAnnotation:", e); } } else { console.warn("ChartAnnotation plugin not found. Average lines on chart will be disabled."); }
                 appElement.addEventListener('click', (event) => { const header = event.target.closest('.card-header[role="button"]'); if (header) { toggleCard(header.closest('.card')); } }); document.querySelectorAll('.card-header[role="button"]').forEach(header => { header.addEventListener('keydown', (e) => { if(e.key==='Enter'||e.key===' '){e.preventDefault(); toggleCard(header.closest('.card'));}}); });
                 changeDateBtn.addEventListener('click', () => setDateInputVisibility(true)); recordHoursInput.addEventListener('input', formatTimeInputOnType); recordHoursInput.addEventListener('blur', validateTimeInputOnBlur); recordNotesInput.addEventListener('input', validateNotesInput); recordForm.addEventListener('submit', handleRecordSubmit); planHoursInput.addEventListener('input', formatTimeInputOnType); planHoursInput.addEventListener('blur', validateTimeInputOnBlur); planForm.addEventListener('submit', handlePlanSubmit); clearPlanFormBtn.addEventListener('click', clearPlanForm); saveGoalBtn.addEventListener('click', handleGoalSave); monthlyGoalInput.addEventListener('keypress', (e)=>{if(e.key==='Enter'){e.preventDefault();handleGoalSave();monthlyGoalInput.blur();}}); clearAllDataBtn.addEventListener('click', handleClearAllData); historySearchInput.addEventListener('input', () => renderHistory()); chartMonthSelector.addEventListener('change', () => updateAllDisplays()); dialogConfirmBtn.addEventListener('click', () => { try {if(typeof currentConfirmCallback === 'function') currentConfirmCallback();} catch(e){} finally {hideConfirmationDialog();}}); dialogCancelBtn.addEventListener('click', hideConfirmationDialog); confirmationDialog.addEventListener('click', (e)=>{if(e.target === confirmationDialog) hideConfirmationDialog();}); window.addEventListener('beforeinstallprompt', (e)=>{ e.preventDefault(); deferredInstallPrompt=e; });
                 planDateInput.min = getCurrentDateString(); // Set min date for planning input
                 recordDateInput.value = getCurrentDateString(); setDateInputVisibility(false); clearRecordForm(); clearPlanForm(); document.querySelectorAll('.card').forEach(card => { const shouldBeExpanded = (card.id === 'record-card'); const isExpanded = card.classList.contains('expanded'); if (isExpanded !== shouldBeExpanded) { card.classList.toggle('expanded', shouldBeExpanded); const icon = card.querySelector('.toggle-icon'); if(icon) icon.textContent = shouldBeExpanded ? i18n.t('toggleIconCollapse') : i18n.t('toggleIconExpand'); } }); // Correct initial toggle state and icon
                 updateAllDisplays();
                 registerServiceWorker();
                 if (!settings.goalHasBeenSet) { setTimeout(promptForMonthlyGoal, 700); }
                 setInterval(updateDashboardPlannedDates, 60 * 1000);
             }

             init().catch(err => { const body = document.body; body.innerHTML = `<div style="padding: 20px; text-align: center; color: #ff453a; font-family: sans-serif;"><h2>Application Error</h2><p>Could not initialize the application. Please check the console for details or try refreshing.</p><pre style="font-size: 0.8em; color: #ccc; text-align: left; white-space: pre-wrap;">${err.message}\n${err.stack}</pre></div>`; });

        });
    </script>
</body>
</html>
