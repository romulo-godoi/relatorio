<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pioneer Field Service Log</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#0A84FF">
    <link rel="apple-touch-icon" href="icon-192x192.png">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        :root {
            --system-font: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            --primary-color: #0A84FF;
            --secondary-color: #000000;
            --card-bg: #1c1c1e;
            --input-bg: #2c2c2e;
            --text-color: #ffffff;
            --text-color-secondary: rgba(235, 235, 245, 0.6);
            --border-color: #3a3a3c;
            --shadow-color: rgba(0, 0, 0, 0.2);
            --danger-color: #FF453A;
            --success-color: #30D158;
            --placeholder-color: rgba(235, 235, 245, 0.3);
            --dialog-backdrop: rgba(0, 0, 0, 0.7);
            --progress-track-color: #38383a;
            --progress-bar-color: var(--success-color);
            --chart-color-1: #0A84FF; --chart-color-2: #30D158; --chart-color-3: #FF9F0A; --chart-color-4: #AF52DE;
            --chart-color-5: #5E5CE6; --chart-color-6: #FF69B4; --chart-color-7: #32CD32; --chart-color-8: #FFD700;
            --font-family: var(--system-font);
            --border-radius: 10px;
            --card-padding: 18px;
            --outer-padding: 15px;
            --transition-speed: 0.3s;
            --transition-speed-fast: 0.1s;
            --content-transition: max-height 0.35s ease-out, opacity 0.25s ease-out 0.1s, padding 0.35s ease-out, margin 0.35s ease-out;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body { height: 100%; -webkit-tap-highlight-color: rgba(0,0,0,0); }
        body { font-family: var(--font-family); background-color: var(--secondary-color); color: var(--text-color); line-height: 1.5; padding: var(--outer-padding); overscroll-behavior-y: contain; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; font-size: 16px; }
        [data-translate-key]::before { content: ""; }
        #loading-indicator { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 9999; color: white; font-size: 1.2em; transition: opacity 0.3s ease-out;}
        #loading-indicator.hidden { opacity: 0; pointer-events: none; }
        #dashboard-box { background-color: var(--card-bg); border-radius: var(--border-radius); padding: 15px var(--card-padding); margin-bottom: 20px; display: flex; justify-content: space-around; align-items: flex-start; text-align: center; gap: 15px; }
        .dashboard-item { position: relative; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; flex: 1; }
        .dashboard-item--progress { width: 90px; height: 90px; flex-shrink: 0; margin-top: 5px; }
        .progress-ring { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: rotate(-90deg); }
        .progress-ring__circle { fill: none; stroke-width: 5; transition: stroke-dashoffset 0.5s ease-out; }
        .progress-ring__bg { stroke: var(--progress-track-color); }
        .progress-ring__fg { stroke: var(--progress-bar-color); stroke-linecap: round; }
        .dashboard-item--progress .dashboard-content { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: flex; flex-direction: column; align-items: center; }
        #dashboard-month-percentage { font-size: 1.6em; color: var(--text-color); margin-bottom: 0; font-weight: 600;}
        .dashboard-item--progress .dashboard-label { margin-top: 2px; margin-bottom: 0; font-size: 0.65em; }
        .dashboard-label { font-size: 0.85em; color: var(--text-color-secondary); margin-bottom: 4px; display: block; }
        .dashboard-value { font-size: 1.4em; font-weight: 500; color: var(--primary-color); line-height: 1.2; margin-bottom: 5px; }
        #dashboard-summary { margin-top: 12px; font-size: 0.85em; color: var(--text-color-secondary); line-height: 1.35; }
        #dashboard-summary strong { color: var(--text-color); font-weight: 500; }
        #dashboard-summary span { display: block; margin-bottom: 3px;}
        #dashboard-planned-dates .dashboard-label { margin-bottom: 8px; margin-top: 15px; }
         #dashboard-plan-list { list-style: none; padding: 0; margin: 0; text-align: left; font-size: 0.8em; line-height: 1.4; color: var(--text-color-secondary); width: 100%; max-height: 60px; overflow: hidden; }
         #dashboard-plan-list li { margin-bottom: 3px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
         #dashboard-plan-list li strong { color: var(--text-color); }
         #dashboard-plan-list .plan-warning { font-size: 0.9em; margin-left: 5px; opacity: 0.7; font-style: italic; }
        #app { max-width: 700px; margin: 0 auto; display: flex; flex-direction: column; gap: 12px; }
        h1 { display: none; }
        .card { background-color: var(--card-bg); border-radius: var(--border-radius); overflow: hidden; transition: box-shadow var(--transition-speed) ease; }
        .card-header { display: flex; justify-content: space-between; align-items: center; padding: 15px var(--card-padding); cursor: pointer; transition: background-color var(--transition-speed-fast) ease; position: relative; }
        .card-header::after { content: ''; position: absolute; bottom: 0; left: var(--card-padding); right: var(--card-padding); height: 1px; background-color: var(--border-color); opacity: 1; transition: opacity var(--transition-speed-fast) ease; }
        .card.expanded .card-header::after { opacity: 0; }
        .card:not(.expanded) .card-header:hover { background-color: rgba(255, 255, 255, 0.03); }
        .card-header h2 { color: var(--text-color); margin-bottom: 0; font-size: 1.15em; font-weight: 600; pointer-events: none; }
        .toggle-icon { font-size: 0.8em; font-weight: bold; transition: transform var(--transition-speed) ease; color: var(--text-color-secondary); margin-left: 10px; width: 20px; height: 20px; display: inline-flex; align-items: center; justify-content: center; pointer-events: none; }
        .card.expanded .toggle-icon { transform: rotate(180deg); }
        .card-content { padding: 0 var(--card-padding) 0 var(--card-padding); max-height: 0; opacity: 0; overflow: hidden; border-top: 1px solid var(--border-color); transition: var(--content-transition); margin-top: -1px; }
        .card.expanded .card-content { padding-top: var(--card-padding); padding-bottom: calc(var(--card-padding) + 5px); max-height: 1500px; opacity: 1; margin-top: 0; overflow: visible; }
        .form-group { margin-bottom: 16px; }
        label { display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-color-secondary); font-size: 0.9em; }
        input[type="date"], input[type="number"], input[type="text"], input[type="search"], textarea, select { width: 100%; padding: 11px 14px; border: 1px solid var(--border-color); border-radius: 8px; font-size: 1em; font-family: var(--font-family); transition: border-color var(--transition-speed) ease, box-shadow var(--transition-speed) ease; appearance: none; -webkit-appearance: none; -moz-appearance: none; background-color: var(--input-bg); color: var(--text-color); }
        input[type="text"].time-input { font-variant-numeric: tabular-nums; }
        input[type="search"] { padding-right: 35px; background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="rgba(235, 235, 245, 0.6)" class="bi bi-search" viewBox="0 0 16 16"><path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"/></svg>'); background-repeat: no-repeat; background-position: right 12px center; background-size: 16px 16px; }
        input[type="search"]::-webkit-search-cancel-button{ appearance: none; height: 14px; width: 14px; background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="rgba(235, 235, 245, 0.6)" class="bi bi-x-circle-fill" viewBox="0 0 16 16"><path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM5.354 4.646a.5.5 0 1 0-.708.708L7.293 8l-2.647 2.646a.5.5 0 0 0 .708.708L8 8.707l2.646 2.647a.5.5 0 0 0 .708-.708L8.707 8l2.647-2.646a.5.5 0 0 0-.708-.708L8 7.293 5.354 4.646z"/></svg>'); background-size: 14px 14px; cursor: pointer; }
        select { background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="rgba(235, 235, 245, 0.6)" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/></svg>'); background-repeat: no-repeat; background-position: right 14px center; background-size: 12px 12px; padding-right: 40px; }
        select:focus { background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="%230A84FF" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/></svg>'); }
        input[type="date"]::-webkit-calendar-picker-indicator { filter: invert(0.8); cursor: pointer; }
        input::placeholder, textarea::placeholder { color: var(--placeholder-color); opacity: 1; }
        input:focus, textarea:focus, select:focus { outline: none; border-color: var(--primary-color); box-shadow: 0 0 0 3px rgba(10, 132, 255, 0.3); }
        input[type="number"] { -moz-appearance: textfield; } input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        textarea { resize: vertical; min-height: 90px; }
        button { background-color: var(--primary-color); color: var(--text-color); border: none; padding: 11px 22px; border-radius: 8px; font-size: 1em; font-weight: 600; cursor: pointer; transition: background-color var(--transition-speed-fast) ease, transform var(--transition-speed-fast) ease, filter var(--transition-speed-fast) ease; display: inline-block; margin-right: 8px; margin-top: 10px; width: auto; transform: scale(1); filter: brightness(1); -webkit-user-select: none; user-select: none; }
        button:hover { filter: brightness(1.15); }
        button:active { transform: scale(0.95); filter: brightness(0.8); transition-duration: 0.05s; }
        button.secondary { background-color: var(--input-bg); color: var(--primary-color); border: 1px solid var(--border-color); } button.secondary:hover { background-color: #3a3a3c; filter: none; } button.secondary:active { background-color: #48484a; transform: scale(0.96); filter: brightness(1); }
        button.success { background-color: var(--success-color); color: var(--text-color); } button.success:hover { filter: brightness(1.15); } button.success:active { transform: scale(0.95); filter: brightness(0.8); }
        button.danger { background-color: var(--danger-color); color: var(--text-color); } button.danger:hover { background-color: #ff3b30; filter: brightness(1.15); } button.danger:active { background-color: #E0352D; transform: scale(0.96); filter: brightness(0.85); }
        #record-form .text-center button, #plan-form .text-center button { width: auto; margin-right: 8px; }
         #record-form .text-center button:last-child { margin-right: 0; }
         @media (min-width: 600px) { #plan-form .text-center button { } }
        .change-date-button { background: none; border: none; color: var(--primary-color); cursor: pointer; font-size: 0.9em; padding: 5px 0; margin-left: 5px; text-align: left; width: auto; margin-right: 0; margin-top: 0; } .change-date-button:hover { text-decoration: underline; } .change-date-button:active { transform: scale(0.95); filter: brightness(0.8); }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 12px; text-align: center; margin-top: 10px;}
        .stat-item { background-color: var(--input-bg); padding: 16px 12px; border-radius: 8px; }
        .stat-value { font-size: 1.7em; font-weight: 600; color: var(--text-color); display: block; margin-bottom: 2px; }
        .stat-label { font-size: 0.85em; color: var(--text-color-secondary); }
        .progress-bar-container { background-color: var(--border-color); border-radius: 5px; overflow: hidden; height: 8px; margin-top: 8px; }
        .progress-bar { background-color: var(--progress-bar-color); height: 100%; width: 0; transition: width var(--transition-speed) ease-out; }
        #history-controls { margin-bottom: 15px; display: flex; gap: 10px; padding: 0 var(--card-padding) }
        .history-search-input { flex-grow: 1; }
        #showing-results-label { font-size: 0.85em; color: var(--text-color-secondary); margin-top: 5px; display: block; text-align: right; padding: 0 var(--card-padding) 5px var(--card-padding) ; min-height: 1.2em;}
        .data-list { list-style: none; padding: 0; max-height: 400px; overflow-y: auto; margin-top: 0; }
        .data-list li { background-color: transparent; border-bottom: 1px solid var(--border-color); padding: 14px var(--card-padding); margin: 0; display: flex; justify-content: space-between; align-items: flex-start; flex-wrap: wrap; transition: background-color var(--transition-speed-fast) ease; }
        .data-list li:last-child { border-bottom: none; }
        .data-list li:hover { background-color: rgba(255, 255, 255, 0.02); }
        .entry-details { font-size: 0.95em; flex-grow: 1; margin-right: 10px; line-height: 1.4; padding-bottom: 5px; }
        .entry-details strong { color: var(--text-color); font-weight: 500; }
        .entry-details .hours { color: var(--primary-color); font-weight: 600; margin-left: 5px; margin-right: 5px; }
        .entry-details .tag-badge { display: inline-block; background-color: var(--input-bg); color: var(--text-color-secondary); font-size: 0.75em; padding: 2px 6px; border-radius: 5px; margin-left: 8px; vertical-align: middle; }
        .entry-details .notes-preview { color: var(--text-color-secondary); font-size: 0.9em; display: block; margin-top: 5px; white-space: normal; overflow-wrap: break-word; max-height: 4.5em; overflow: hidden; }
        .entry-actions { flex-shrink: 0; align-self: center; }
        .entry-actions button, .plan-actions button { padding: 6px 10px; font-size: 0.85em; margin-left: 5px; margin-top: 0; width: auto; border-radius: 6px; }
        .plan-actions button { margin-top: 5px; }
        .entry-actions button.secondary, .plan-actions button.secondary { background-color: #3a3a3c; }
        .chart-container { position: relative; min-height: 300px; max-height: 400px; width: 100%; margin-top: 15px; }
        .chart-summary-text { text-align: center; font-size: 0.95em; font-weight: 500; color: var(--text-color-secondary); margin-bottom: 10px; margin-top: 5px; min-height: 1.3em; padding: 0 var(--card-padding); }
        .dialog-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--dialog-backdrop); display: flex; justify-content: center; align-items: center; z-index: 1000; opacity: 0; visibility: hidden; transition: opacity var(--transition-speed) ease, visibility var(--transition-speed) ease; }
        .dialog-backdrop.visible { opacity: 1; visibility: visible; }
        .dialog-content { background-color: #2c2c2e; color: var(--text-color); padding: 25px; border-radius: 14px; box-shadow: 0 8px 30px rgba(0,0,0,0.4); text-align: center; max-width: 90%; width: 320px; transform: scale(0.95); transition: transform var(--transition-speed) ease; }
        .dialog-backdrop.visible .dialog-content { transform: scale(1); }
        .dialog-content p { margin-bottom: 25px; font-size: 1.05em; line-height: 1.5; }
        .dialog-actions button { width: calc(50% - 5px); margin-top: 0; padding: 10px; font-size: 1em;}
        .hidden { display: none !important; }
        .visually-hidden { position: absolute; width: 1px; height: 1px; margin: -1px; padding: 0; overflow: hidden; clip: rect(0, 0, 0, 0); border: 0; }
        .text-center { text-align: center; } .mt-1 { margin-top: 10px; } .mt-2 { margin-top: 20px; }
    </style>
</head>
<body>
    <div id="loading-indicator">Loading...</div>

    <div id="dashboard-box"> <div class="dashboard-item" style="align-items: flex-start; text-align: left;"> <span class="dashboard-label" data-translate-key="dashboard.weekHoursLabel"></span> <span id="dashboard-week-hours" class="dashboard-value">0</span> <div id="dashboard-summary" style="margin-top: 12px;"> <span id="dashboard-month-total"></span> <span id="dashboard-forecast"></span> </div> <div class="hidden" id="dashboard-planned-dates"> <span class="dashboard-label" data-translate-key="dashboard.plannedTripsLabel"></span> <ul id="dashboard-plan-list"></ul> </div> </div> <div class="dashboard-item dashboard-item--progress"> <svg viewBox="0 0 36 36" class="progress-ring"> <circle class="progress-ring__circle progress-ring__bg" cx="18" cy="18" r="15.9155"></circle> <circle id="progress-ring-fg" class="progress-ring__circle progress-ring__fg" cx="18" cy="18" r="15.9155" stroke-dasharray="100 100" stroke-dashoffset="100"></circle> </svg> <div class="dashboard-content"> <span id="dashboard-month-percentage" class="dashboard-value">0%</span> <span class="dashboard-label" data-translate-key="dashboard.monthGoalLabel"></span> </div> </div> </div>
    <div id="app">
        <div class="card expanded" id="record-card"> <div class="card-header"> <h2 data-translate-key="recordCard.title"></h2> <span class="toggle-icon">▲</span></div> <div class="card-content"> <form id="record-form"><input type="hidden" id="record-id"> <div class="form-group"><label for="record-date" id="date-label"> <span data-translate-key="recordCard.dateLabel"></span>: <strong id="display-date"></strong> <button type="button" class="change-date-button" id="change-date-btn" data-translate-key="recordCard.changeDateButton"></button></label> <input type="date" id="record-date" class="hidden"></div> <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;"> <div class="form-group"> <label for="record-hours" data-translate-key="recordCard.timeLabel"></label> <input type="text" inputmode="numeric" id="record-hours" class="time-input" required data-translate-key="recordCard.timePlaceholder" data-translate-attr="placeholder"></div> <div class="form-group"> <label for="record-tag" data-translate-key="recordCard.tagLabel"></label> <select id="record-tag"></select></div> </div> <div class="form-group"> <label for="record-notes" id="record-notes-label" data-translate-key="recordCard.notesLabel"></label> <textarea id="record-notes" rows="3" data-translate-key="recordCard.notesPlaceholder" data-translate-attr="placeholder"></textarea></div> <div class="text-center" style="margin-top: 20px;"> <button type="submit" id="save-record-btn" data-translate-key="recordCard.saveButton"></button> </div> </form> </div> </div>
        <div class="card" id="plan-card"> <div class="card-header"><h2 data-translate-key="planCard.title"></h2><span class="toggle-icon">▼</span></div> <div class="card-content"> <form id="plan-form"><input type="hidden" id="plan-id"><div class="form-group"><label for="plan-date" data-translate-key="planCard.dateLabel"></label><input type="date" id="plan-date" required></div> <div class="form-group"><label for="plan-hours" data-translate-key="planCard.hoursLabel"></label> <input type="text" inputmode="numeric" id="plan-hours" class="time-input" required data-translate-key="planCard.hoursPlaceholder" data-translate-attr="placeholder"></div> <div class="text-center"> <button type="submit" id="save-plan-btn" data-translate-key="planCard.saveButton"></button> <button type="button" id="clear-plan-form-btn" class="secondary" data-translate-key="planCard.clearButton"></button> </div> </form> <div id="planning-list-container" class="mt-2"> <h3 style="font-size: 1em; font-weight: 600; color: var(--text-color-secondary); margin-bottom: 10px; padding-left: var(--card-padding);" data-translate-key="planCard.listTitle"></h3> <ul id="planning-list" class="data-list"> <li class="placeholder hidden" style="padding-left: var(--card-padding);"></li></ul></div> </div> </div>
        <div class="card" id="stats-card"> <div class="card-header"><h2 data-translate-key="statsCard.title"></h2><span class="toggle-icon">▼</span></div> <div class="card-content"> <div class="form-group" style="max-width: 200px; margin: 0 auto 25px auto; text-align:center;"> <label for="monthly-goal" data-translate-key="statsCard.goalLabel"></label> <input type="number" id="monthly-goal" min="1" step="1" value="70"> <button id="save-goal-btn" class="mt-1 secondary" style="width:100%; font-size:0.9em; padding: 8px 10px;" data-translate-key="statsCard.setGoalButton"></button></div> <div class="stats-grid"> <div class="stat-item"><span id="stats-month-hours" class="stat-value">0</span><span class="stat-label" data-translate-key="statsCard.monthHoursLabel"></span></div> <div class="stat-item"><span id="stats-month-goal-progress" class="stat-value">0%</span><span class="stat-label" data-translate-key="statsCard.goalProgressLabel"></span><div class="progress-bar-container"><div id="stats-month-progress-bar" class="progress-bar"></div></div></div> <div class="stat-item"><span id="stats-avg-hours-day" class="stat-value">0</span><span class="stat-label" data-translate-key="statsCard.avgHoursDayLabel"></span></div> <div class="stat-item"><span id="stats-month-days-active" class="stat-value">0</span><span class="stat-label" data-translate-key="statsCard.daysActiveLabel"></span></div></div> </div> </div>
        <div class="card" id="charts-card"> <div class="card-header"><h2 data-translate-key="chartsCard.title"></h2><span class="toggle-icon">▼</span></div> <div class="card-content"> <div class="form-group"> <label for="chart-month-selector" data-translate-key="chartsCard.monthSelectorLabel"></label> <select id="chart-month-selector"></select></div> <p id="chart-total-hours-display" class="chart-summary-text"></p> <div class="chart-container"> <canvas id="monthlyHoursChart"></canvas></div> </div> </div>
        <div class="card" id="history-card"> <div class="card-header"><h2 data-translate-key="historyCard.title"></h2><span class="toggle-icon">▼</span></div> <div class="card-content"> <div id="history-controls"> <input type="search" id="history-search-input" class="history-search-input" data-translate-key="historyCard.searchPlaceholder" data-translate-attr="placeholder"></div> <span id="showing-results-label"></span> <ul id="history-list" class="data-list"> <li class="placeholder hidden" style="padding-left: var(--card-padding);"></li> </ul></div> </div>
        <div class="card" id="settings-card"> <div class="card-header"><h2 data-translate-key="settingsCard.title"></h2><span class="toggle-icon">▼</span></div> <div class="card-content"> <div class="text-center"> <button id="clear-all-data-btn" class="danger" data-translate-key="settingsCard.clearDataButton"></button></div> <p id="settings-warning-text" style="margin-top: 15px; font-size: 0.9em; color: var(--text-color-secondary); text-align: center; line-height: 1.4;" data-translate-key="settingsCard.clearDataWarning"></p> </div> </div>
    </div>
    <div id="confirmation-dialog" class="dialog-backdrop"> <div class="dialog-content"> <p id="dialog-message"></p> <div class="dialog-actions"> <button id="dialog-confirm-btn" class="danger" data-translate-key="dialog.confirmButton"></button> <button id="dialog-cancel-btn" class="secondary" data-translate-key="dialog.cancelButton"></button> </div> </div> </div>

    <script>
        (async () => {
            // --- Translation & Setup Variables (unchanged) ---
            let translations = {};
            let currentLang = 'en';
            const supportedLanguages = ["pt-BR", "en", "es", "de", "fr"];
            const tagKeyMapping = {
                "Casa em casa": "tags.houseToHouse", "Carrinho": "tags.cart",
                "Cartas": "tags.letters", "Telefone": "tags.phone", "Outro": "tags.other"
            };
            const DEFAULT_TAG_VALUE = "Casa em casa";

            function getNestedValue(obj, key) {
                 if (!key || typeof key !== 'string') return undefined;
                 return key.split('.').reduce((acc, part) => acc && acc[part] !== undefined ? acc[part] : undefined, obj);
             }

             function t(key, variables = {}) {
                 const langObj = translations?.[currentLang] || translations?.['en'];
                 if (!langObj) { console.error(`Language missing: ${currentLang} & 'en'. Key: ${key}`); return `[NO LANG: ${key}]`; }
                 let translation = getNestedValue(langObj, key);
                 if (translation === undefined) {
                     console.warn(`Translation missing for key "${key}" in "${currentLang}", trying 'en'`);
                     const fallbackLangObj = translations['en'];
                     if (fallbackLangObj) translation = getNestedValue(fallbackLangObj, key);
                     if (translation === undefined) return `[MISSING: ${key}]`;
                 }
                 if (typeof translation !== 'string') {
                     console.warn(`Translation key "${key}" is not a string:`, translation);
                     return `[TYPE ERR: ${key}]`;
                 }
                 for (const placeholder in variables) { if (Object.prototype.hasOwnProperty.call(variables, placeholder)) { translation = translation.replace(new RegExp(`\\{${placeholder}\\}`, 'g'), variables[placeholder]); } }
                 return translation;
             }

            function applyStaticTranslations() {
                 document.querySelectorAll('[data-translate-key]').forEach(element => {
                     const key = element.getAttribute('data-translate-key');
                     const attr = element.getAttribute('data-translate-attr') || 'textContent';
                     const translation = t(key);
                     if (translation && !translation.startsWith('[')) {
                         if (attr === 'textContent') element.textContent = translation;
                         else if (['placeholder', 'title', 'value'].includes(attr)) element.setAttribute(attr, translation);
                     }
                 });
                 if (recordTagSelect) {
                     const currentVal = recordTagSelect.value;
                     recordTagSelect.innerHTML = '';
                     Object.keys(tagKeyMapping).forEach(internalValue => {
                         const option = document.createElement('option'); option.value = internalValue; option.textContent = t(tagKeyMapping[internalValue] || 'tags.noTag'); recordTagSelect.appendChild(option);
                     });
                     if (recordTagSelect.querySelector(`option[value="${currentVal}"]`)) recordTagSelect.value = currentVal;
                     else recordTagSelect.value = DEFAULT_TAG_VALUE;
                 }
                 document.title = t('appTitle');
                 document.documentElement.lang = currentLang.split('-')[0];
                  if (recordNotesLabel) recordNotesLabel.textContent = t('recordCard.notesLabel', { maxLength: NOTES_MAX_LENGTH });
                  if (recordNotesInput) recordNotesInput.maxLength = NOTES_MAX_LENGTH;
                 if (loadingIndicator) loadingIndicator.textContent = t('common.loading');
             }

            // --- Element & State Variables (unchanged) ---
            let appElement, dashboardWeekHours, dashboardMonthPercentage, dashboardMonthTotal, dashboardForecast, dashboardPlannedDatesContainer, dashboardPlanList, progressRingFg, recordCard, recordForm, recordIdInput, recordDateInput, dateLabel, displayDate, changeDateBtn, recordHoursInput, recordTagSelect, recordNotesInput, recordNotesLabel, saveRecordBtn, planCard, planForm, planIdInput, planDateInput, planHoursInput, savePlanBtn, clearPlanFormBtn, planningList, planningListPlaceholder, monthlyGoalInput, saveGoalBtn, statsMonthHours, statsMonthGoalProgress, statsMonthProgressBar, statsAvgHoursDay, statsMonthDaysActive, chartMonthSelector, monthlyHoursChartCtx, historyList, historySearchInput, historyListPlaceholder, showingResultsLabel, clearAllDataBtn, confirmationDialog, dialogMessage, dialogConfirmBtn, dialogCancelBtn, computedStyles, textColor, textMutedColor, tooltipBgColor, chartTotalHoursDisplay, chartColors = [];
            let recordedEntries = [], plannedEntries = [], settings = { monthlyGoal: 70, goalHasBeenSet: false };
            let monthlyHoursChartInstance = null, currentEditingId = null, currentConfirmCallback = null, isDateInputVisible = false, deferredInstallPrompt = null;
            let progressRingRadius = 0, progressRingCircumference = 0, MONTH_NAMES = [], WEEKDAY_NAMES = [];

            const HISTORY_MONTH_LIMIT = 3;
            const NOTES_MAX_LENGTH = 300;
            const MIN_HOURS_PER_DAY_FORECAST = 1.0;
            const LOCAL_STORAGE_KEYS = { ENTRIES: 'pioneerTracker_entries_v5.1', PLANS: 'pioneerTracker_plans_v1.1', SETTINGS: 'pioneerTracker_settings_v1.1' };

            const loadingIndicator = document.getElementById('loading-indicator');
            if (loadingIndicator) loadingIndicator.classList.remove('hidden');

            // --- Translation Loading (unchanged, includes corrected MONTH/WEEKDAY fetching) ---
            try {
                 const response = await fetch('translations.json');
                 if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                 translations = await response.json();
                 const browserLang = (navigator.language || 'en').split('-')[0]; const browserLocale = navigator.language || 'en';
                 if (translations[browserLocale] && supportedLanguages.includes(browserLocale)) currentLang = browserLocale;
                 else if (translations[browserLang] && supportedLanguages.includes(browserLang)) currentLang = browserLang;
                 else if (translations['en']) currentLang = 'en';
                 else throw new Error("'en' missing in translations.json");
                 console.log("Selected language:", currentLang);

                 MONTH_NAMES = getNestedValue(translations[currentLang], 'dates.monthNames') || getNestedValue(translations['en'], 'dates.monthNames');
                 WEEKDAY_NAMES = getNestedValue(translations[currentLang], 'dates.weekdaysShort') || getNestedValue(translations['en'], 'dates.weekdaysShort');

                 if (!Array.isArray(MONTH_NAMES) || MONTH_NAMES.length !== 12) {
                     console.warn(`Month names for "${currentLang}" (and 'en') seem invalid or missing in translations.json. Using default fallback.`);
                     MONTH_NAMES = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
                 }
                 if (!Array.isArray(WEEKDAY_NAMES) || WEEKDAY_NAMES.length !== 7) {
                     console.warn(`Weekday names for "${currentLang}" (and 'en') seem invalid or missing in translations.json. Using default fallback.`);
                     WEEKDAY_NAMES = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
                 }

            } catch (error) {
                console.error('FATAL: Error loading/processing translations:', error);
                 if (loadingIndicator) loadingIndicator.textContent = 'Error loading language file!';
                 alert("Could not load language data. UI might be broken.");
                 MONTH_NAMES = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
                 WEEKDAY_NAMES = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
            }

            // --- Element Assignments (unchanged) ---
            appElement = document.getElementById('app'); dashboardWeekHours = document.getElementById('dashboard-week-hours'); dashboardMonthPercentage = document.getElementById('dashboard-month-percentage'); dashboardMonthTotal = document.getElementById('dashboard-month-total'); dashboardForecast = document.getElementById('dashboard-forecast'); dashboardPlannedDatesContainer = document.getElementById('dashboard-planned-dates'); dashboardPlanList = document.getElementById('dashboard-plan-list'); progressRingFg = document.getElementById('progress-ring-fg'); recordCard = document.getElementById('record-card'); recordForm = document.getElementById('record-form'); recordIdInput = document.getElementById('record-id'); recordDateInput = document.getElementById('record-date'); dateLabel = document.getElementById('date-label'); displayDate = document.getElementById('display-date'); changeDateBtn = document.getElementById('change-date-btn'); recordHoursInput = document.getElementById('record-hours'); recordTagSelect = document.getElementById('record-tag'); recordNotesInput = document.getElementById('record-notes'); recordNotesLabel = document.getElementById('record-notes-label'); saveRecordBtn = document.getElementById('save-record-btn'); planCard = document.getElementById('plan-card'); planForm = document.getElementById('plan-form'); planIdInput = document.getElementById('plan-id'); planDateInput = document.getElementById('plan-date'); planHoursInput = document.getElementById('plan-hours'); savePlanBtn = document.getElementById('save-plan-btn'); clearPlanFormBtn = document.getElementById('clear-plan-form-btn'); planningList = document.getElementById('planning-list'); planningListPlaceholder = planningList?.querySelector('.placeholder'); monthlyGoalInput = document.getElementById('monthly-goal'); saveGoalBtn = document.getElementById('save-goal-btn'); statsMonthHours = document.getElementById('stats-month-hours'); statsMonthGoalProgress = document.getElementById('stats-month-goal-progress'); statsMonthProgressBar = document.getElementById('stats-month-progress-bar'); statsAvgHoursDay = document.getElementById('stats-avg-hours-day'); statsMonthDaysActive = document.getElementById('stats-month-days-active'); chartMonthSelector = document.getElementById('chart-month-selector'); monthlyHoursChartCtx = document.getElementById('monthlyHoursChart')?.getContext('2d'); historyList = document.getElementById('history-list'); historySearchInput = document.getElementById('history-search-input'); historyListPlaceholder = historyList?.querySelector('.placeholder'); showingResultsLabel = document.getElementById('showing-results-label'); clearAllDataBtn = document.getElementById('clear-all-data-btn'); confirmationDialog = document.getElementById('confirmation-dialog'); dialogMessage = document.getElementById('dialog-message'); dialogConfirmBtn = document.getElementById('dialog-confirm-btn'); dialogCancelBtn = document.getElementById('dialog-cancel-btn'); chartTotalHoursDisplay = document.getElementById('chart-total-hours-display');

            // --- Style & Ring Calculations (unchanged) ---
            try { computedStyles = getComputedStyle(document.body); } catch (e) { console.error("Cannot get computed styles"); computedStyles = {}; } textColor = computedStyles.getPropertyValue?.('--text-color')?.trim() || '#ffffff'; textMutedColor = computedStyles.getPropertyValue?.('--text-color-secondary')?.trim() || '#aaaaaa'; tooltipBgColor = computedStyles.getPropertyValue?.('--card-bg')?.trim() || '#1c1c1e'; chartColors = ['#0A84FF', '#30D158', '#FF9F0A', '#AF52DE', '#5E5CE6', '#FF69B4', '#32CD32', '#FFD700'].map((fallback, i) => computedStyles.getPropertyValue?.(`--chart-color-${i+1}`)?.trim() || fallback); if (progressRingFg && progressRingFg.r?.baseVal?.value) { progressRingRadius = progressRingFg.r.baseVal.value; progressRingCircumference = 2 * Math.PI * progressRingRadius; }


             // --- START OF HELPER FUNCTIONS SECTION ---

             // Corrected Date/Time Helpers (from previous step)
             function getCurrentDateString() {
                 const t = new Date();
                 return `${t.getFullYear()}-${String(t.getMonth() + 1).padStart(2, '0')}-${String(t.getDate()).padStart(2, '0')}`;
             }
             function parseLocalDate(dateString) {
                 if (!dateString || !/^\d{4}-\d{2}-\d{2}$/.test(dateString)) {
                    console.warn("Invalid date string passed to parseLocalDate:", dateString);
                    return new Date(NaN);
                 }
                 const [y, m, d] = dateString.split('-').map(Number);
                 return new Date(y, m - 1, d);
             }
             function formatDisplayDate(dateString) {
                 if (!dateString || !dateString.includes('-')) return dateString;
                 try {
                     const date = parseLocalDate(dateString);
                     if (isNaN(date.valueOf())) throw new Error("Invalid date created");
                     const options = { day: '2-digit', month: '2-digit', year: 'numeric' };
                     return new Intl.DateTimeFormat(currentLang.split('-')[0] || 'default', options).format(date);
                 } catch (e) {
                    console.error("Error formatting display date:", dateString, e);
                    const [y, m, d] = dateString.split('-');
                    return `${d}/${m}/${y}`;
                 }
             }
             function getMonthYearString(date) {
                 const m = String(date.getMonth() + 1).padStart(2, '0');
                 const y = date.getFullYear();
                 return `${m}/${y}`;
             }
             function getStartOfWeek(date = new Date()) {
                 const d = new Date(date);
                 d.setHours(0, 0, 0, 0);
                 const dayOfWeek = d.getDay();
                 const diff = d.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1);
                 const sOW = new Date(d.setDate(diff));
                 return `${sOW.getFullYear()}-${String(sOW.getMonth() + 1).padStart(2, '0')}-${String(sOW.getDate()).padStart(2, '0')}`;
             }
             function getDateMonthsAgo(months) {
                 const d = new Date();
                 d.setHours(0, 0, 0, 0);
                 d.setMonth(d.getMonth() - months);
                 return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
             }
             function formatMonthYearExtensive(monthYearString) {
                 if (!monthYearString || !monthYearString.includes('/') || !Array.isArray(MONTH_NAMES) || MONTH_NAMES.length<12) return monthYearString;
                 const [m,y]=monthYearString.split('/');
                 const idx=parseInt(m,10)-1;
                 if(idx<0 || idx>11) return monthYearString;
                 return `${MONTH_NAMES[idx]} ${y}`;
             }

            // --- FUNCTIONS RESTORED ---
             function formatHoursExtensive(hoursDecimal, short=false) {
                 if (isNaN(hoursDecimal) || hoursDecimal < 0) hoursDecimal = 0;
                 const totalMinutes = Math.round(hoursDecimal * 60);
                 const hours = Math.floor(totalMinutes / 60);
                 const minutes = totalMinutes % 60;
                 const hKey = short?(hours === 1?'units.hour_short':'units.hours_short'):(hours === 1?'units.hour':'units.hours');
                 const mKey = short?(minutes === 1?'units.minute_short':'units.minutes_short'):(minutes === 1?'units.minute':'units.minutes');
                 let result='', hPart='', mPart='';
                 if (hours>0){const hUnit=t(hKey); hPart=`${hours}${short?hUnit:' '+hUnit}`;}
                 if (minutes>0){const mUnit=t(mKey); mPart=`${minutes}${short?mUnit:' '+mUnit}`;}
                 if (hPart && mPart){const connector=short?" ":` ${t('units.andConnector')} `; result=`${hPart}${connector}${mPart}`;}
                 else{result=hPart||mPart;}
                 if(result===''){const zeroKey=short?'units.hours_short':'units.hours'; result=`0${short?t(zeroKey):' '+t(zeroKey,{count:0})}`;} // Use {count: 0} for pluralization
                 return result;
             }

             function formatDecimalToTimeInput(d) {
                 if(isNaN(d)||d<=0)return"";
                 const t=Math.round(d*60), h=Math.floor(t/60), m=t%60;
                 return `${h}:${String(m).padStart(2,'0')}`;
             }

             function parseTimeInputToDecimal(s) {
                 if(!s)return 0; const t=s.trim(); if(!t)return 0;
                 // Try H:MM format
                 const c=t.match(/^(\d{1,3}):(\d{1,2})$/);
                 if(c){
                     const h=parseInt(c[1],10), m=parseInt(c[2],10);
                     if(!isNaN(h)&&!isNaN(m)&&m>=0&&m<60&&h>=0)return h+(m/60);
                 }
                 // Try HMM or MM or M format (e.g., 130 -> 1:30, 30 -> 0:30, 5 -> 0:05)
                 const n=t.match(/^(\d+)$/);
                 if(n){
                     const str=n[1],v=parseInt(str,10); if(isNaN(v))return NaN; // Invalid if not a number
                     // Treat 1 or 2 digits as minutes (e.g., 30 -> 0.5, 5 -> 0.0833)
                     if(str.length<=2){
                         if(v<60)return v/60;
                         // Don't allow > 60 if only 2 digits (e.g. '75') - could be ambiguous
                         // Allow it if explicitly more than 2 digits (e.g. '175' for 1h 75m is handled below)
                         // Or maybe treat '75' as 1h 15m? Stick to MM for simplicity for now.
                     }
                     // Treat 3 or 4 digits as H...MM (e.g., 130 -> 1:30, 1215 -> 12:15)
                     if(str.length>=3){
                         const hs=str.slice(0,-2), ms=str.slice(-2);
                         const h=parseInt(hs,10), m=parseInt(ms,10);
                         if(!isNaN(h)&&!isNaN(m)&&m>=0&&m<60&&h>=0)return h+(m/60);
                     }
                 }
                 // If nothing matches, return NaN (or could return 0 or throw error)
                 return NaN;
             }
            // --- END OF FUNCTIONS RESTORED ---


             // Corrected Date/Time Helper (formatRelativeDate, from previous step)
             function formatRelativeDate(dateString) {
                 const today = new Date(); today.setHours(0, 0, 0, 0);
                 const inputDate = parseLocalDate(dateString);

                 if (isNaN(inputDate.valueOf()) || !Array.isArray(WEEKDAY_NAMES) || WEEKDAY_NAMES.length < 7) {
                     return formatDisplayDate(dateString);
                 }

                 const tomorrow = new Date(today); tomorrow.setDate(today.getDate() + 1);
                 const week = new Date(today); week.setDate(today.getDate() + 7);

                 const inputTime = inputDate.getTime();
                 const todayTime = today.getTime();
                 const tomorrowTime = tomorrow.getTime();

                 if (inputTime === todayTime) return t('dates.today');
                 if (inputTime === tomorrowTime) return t('dates.tomorrow');
                 if (inputDate > tomorrow && inputDate < week) {
                     return `${t('dates.nextPrefix')} ${WEEKDAY_NAMES[inputDate.getDay()]}`;
                 }

                 return formatDisplayDate(dateString);
             }


             // --- Other Helper Functions (saveData, loadData, etc. - includes corrected sorting from previous step) ---
             function saveData() { try{localStorage.setItem(LOCAL_STORAGE_KEYS.ENTRIES,JSON.stringify(recordedEntries)); localStorage.setItem(LOCAL_STORAGE_KEYS.PLANS,JSON.stringify(plannedEntries)); localStorage.setItem(LOCAL_STORAGE_KEYS.SETTINGS,JSON.stringify(settings));}catch(e){console.error("Save Err:",e); showFeedback('feedback.saveError','danger');} }
             function loadData() {
                 try{
                     let sER = localStorage.getItem(LOCAL_STORAGE_KEYS.ENTRIES);
                     if(sER){try{const p=JSON.parse(sER); recordedEntries=Array.isArray(p)?p.map(e=>({...e, notes:e.notes?.substring(0,NOTES_MAX_LENGTH)||'', tag:e.tag||DEFAULT_TAG_VALUE})):(()=>{throw new Error("Entries not array")})(); }catch(e){console.error("Parse Err:",e);recordedEntries=[]; localStorage.removeItem(LOCAL_STORAGE_KEYS.ENTRIES);}}
                     const sP=localStorage.getItem(LOCAL_STORAGE_KEYS.PLANS);
                     plannedEntries=sP?JSON.parse(sP):[];
                     plannedEntries.forEach(p=>{if(p.plannedHours!==undefined && typeof p.plannedHours==='number'){p.hours=p.plannedHours;delete p.plannedHours;}});
                     const sSR=localStorage.getItem(LOCAL_STORAGE_KEYS.SETTINGS);
                     settings={monthlyGoal:70,goalHasBeenSet:false, ...JSON.parse(sSR||'{}')};
                     if(isNaN(settings.monthlyGoal)||settings.monthlyGoal<=0)settings.monthlyGoal=70;
                     if(typeof settings.goalHasBeenSet!=='boolean')settings.goalHasBeenSet=false;

                     recordedEntries.sort((a, b) => b.date.localeCompare(a.date)); // Sort YYYY-MM-DD strings
                     plannedEntries.sort((a, b) => a.date.localeCompare(b.date)); // Sort YYYY-MM-DD strings

                     console.log("Data loaded.");
                 }catch(e){
                     console.error("Load Err:",e);
                     recordedEntries=[];plannedEntries=[]; settings={monthlyGoal:70,goalHasBeenSet:false};
                     try{localStorage.clear();}catch(se){}
                     showFeedback('feedback.loadError','danger');
                 }
             }
             function triggerInstallPromptIfAvailable(c='?') { if(deferredInstallPrompt && settings.goalHasBeenSet) {console.log(`Prompting install (${c})...`); setTimeout(() => { deferredInstallPrompt.prompt().then(r=>console.log('Prompt:',r.outcome)).catch(e=>console.error("Prompt err:",e)); deferredInstallPrompt=null;},300);}}
             function promptForMonthlyGoal() { let ok=false; const msg=t('statsCard.goalLabel'); while(!ok){ const inp=prompt(msg, settings.monthlyGoal); if(inp===null){ ok=true; if(!settings.goalHasBeenSet){ settings.goalHasBeenSet=true; saveData(); updateAllDisplays();}} else{ const g=parseInt(inp,10); if(!isNaN(g)&&g>0){ settings.monthlyGoal=g; settings.goalHasBeenSet=true; monthlyGoalInput.value=g; saveData(); ok=true; updateAllDisplays(); showFeedback("feedback.goalSetSuccess","success"); triggerInstallPromptIfAvailable('initial goal');}else{alert(t("feedback.invalidGoalValue"));}}}}
             function setDateInputVisibility(v) { isDateInputVisible=v; if(v){ recordDateInput?.classList.remove('hidden'); dateLabel?.classList.add('visually-hidden'); recordDateInput?.focus(); } else{ recordDateInput?.classList.add('hidden'); dateLabel?.classList.remove('visually-hidden'); if (displayDate) displayDate.textContent=(!recordDateInput?.value || recordDateInput.value===getCurrentDateString())?t('dates.today'):formatDisplayDate(recordDateInput.value);}}
             function toggleCard(e) { if(!e)return;const ex=e.classList.contains('expanded');e.classList.toggle('expanded',!ex); const i=e.querySelector('.toggle-icon'); if(i) i.textContent=!ex?'▲':'▼';}
             function clearRecordForm() { recordForm?.reset(); if(recordIdInput)recordIdInput.value=''; if(recordDateInput)recordDateInput.value=getCurrentDateString(); setDateInputVisibility(false); if(recordTagSelect)recordTagSelect.value=DEFAULT_TAG_VALUE; if(recordNotesInput)recordNotesInput.value=''; if(recordHoursInput)recordHoursInput.value=''; if(saveRecordBtn)saveRecordBtn.textContent=t('recordCard.saveButton'); saveRecordBtn?.classList.remove('editing'); currentEditingId=null;}
             function handleRecordSubmit(event) { event.preventDefault(); const id=recordIdInput?.value?parseInt(recordIdInput.value,10):Date.now(); const date=(isDateInputVisible||(recordDateInput?.value && recordDateInput.value!==getCurrentDateString()))?recordDateInput.value:getCurrentDateString(); const hours=parseTimeInputToDecimal(recordHoursInput?.value); const tag=recordTagSelect?.value||DEFAULT_TAG_VALUE; const notes=recordNotesInput?.value.trim().substring(0,NOTES_MAX_LENGTH); if(isNaN(hours)||hours<=0){alert(t('feedback.invalidTimeFormat'));recordHoursInput?.focus(); return;} if(!date){alert(t('feedback.invalidDate'));return;} const entry={id,date,hours,tag,notes}; const idx=recordedEntries.findIndex(e=>e.id===id); if(idx>-1)recordedEntries[idx]=entry; else recordedEntries.push(entry); recordedEntries.sort((a, b) => b.date.localeCompare(a.date)); saveData(); clearRecordForm(); updateAllDisplays(); showFeedback('feedback.recordSavedSuccess','success'); }
             function editRecordEntry(id) { const entry=recordedEntries.find(e=>e.id===id); if(entry){ if(!recordCard?.classList.contains('expanded'))toggleCard(recordCard); currentEditingId=id; if(recordIdInput)recordIdInput.value=entry.id; if(recordDateInput)recordDateInput.value=entry.date; setDateInputVisibility(entry.date!==getCurrentDateString()); if(recordHoursInput)recordHoursInput.value=formatDecimalToTimeInput(entry.hours); if(recordTagSelect)recordTagSelect.value=entry.tag||DEFAULT_TAG_VALUE; if(recordNotesInput)recordNotesInput.value=entry.notes||''; if(saveRecordBtn){saveRecordBtn.textContent=t('recordCard.updateButton');saveRecordBtn.classList.add('editing');} recordCard?.scrollIntoView({behavior:'smooth', block:'start'}); recordHoursInput?.focus();}}
             function deleteRecordEntry(id) { showConfirmationDialog(t('dialog.confirmDeleteRecordMessage'),()=>{const i=recordedEntries.findIndex(e=>e.id===id); if(i>-1){recordedEntries.splice(i,1);saveData();updateAllDisplays();showFeedback('feedback.recordDeletedSuccess','info');if(currentEditingId===id)clearRecordForm();}else console.warn("Not found for del:", id);});}
             function clearPlanForm() { planForm?.reset(); if(planIdInput)planIdInput.value=''; if(planDateInput)planDateInput.value=''; if(planHoursInput)planHoursInput.value=''; if(savePlanBtn)savePlanBtn.textContent=t('planCard.saveButton'); currentEditingId=null; }
             function handlePlanSubmit(event) { event.preventDefault(); const id=planIdInput?.value?parseInt(planIdInput.value,10):Date.now(); const date=planDateInput?.value; const hours=parseTimeInputToDecimal(planHoursInput?.value); const todayStr=getCurrentDateString(); if(!date||isNaN(hours)||hours<=0){alert(t('feedback.planFormInvalid')); planHoursInput?.focus();return;} if(date<todayStr){alert(t('feedback.planDatePastError'));planDateInput?.focus();return;} const plan={id,date,hours}; const idx=plannedEntries.findIndex(p=>p.id===id); if(idx>-1)plannedEntries[idx]=plan; else plannedEntries.push(plan); plannedEntries.sort((a, b) => a.date.localeCompare(b.date)); saveData(); clearPlanForm(); updateAllDisplays(); showFeedback('feedback.planSavedSuccess','success'); }
             function markPlanAsDone(id) { const idx=plannedEntries.findIndex(p=>p.id===id); if(idx===-1){showFeedback('feedback.planNotFound','danger');return;} const plan=plannedEntries[idx]; const todayStr=getCurrentDateString(); const recDate=todayStr<plan.date?todayStr:plan.date; const note=t('recordCard.autoNoteFromPlan',{date:formatDisplayDate(plan.date),hours:formatHoursExtensive(plan.hours)}); const entry={id:Date.now(),date:recDate,hours:plan.hours,tag:DEFAULT_TAG_VALUE,notes:note}; recordedEntries.push(entry); recordedEntries.sort((a, b) => b.date.localeCompare(a.date)); plannedEntries.splice(idx,1); saveData(); updateAllDisplays(); showFeedback('feedback.planMarkedDoneSuccess','success'); }
             function deletePlanEntry(id){ showConfirmationDialog(t('dialog.confirmDeletePlanMessage'),()=>{plannedEntries=plannedEntries.filter(p=>p.id!==id); saveData(); updateAllDisplays(); showFeedback('feedback.planDeletedSuccess','info'); if(currentEditingId===id)clearPlanForm();});}
             function handleGoalSave(){ const g=parseInt(monthlyGoalInput?.value,10); if(!isNaN(g)&&g>0){settings.monthlyGoal=g;settings.goalHasBeenSet=true;saveData();updateAllDisplays();showFeedback('feedback.goalUpdateSuccess','success');triggerInstallPromptIfAvailable('goal save');}else{alert(t('feedback.invalidGoalValue')); if(monthlyGoalInput) monthlyGoalInput.value=settings.monthlyGoal;}}
             function handleClearAllData() { showConfirmationDialog(t('dialog.confirmClearAllDataMessage'),()=>{recordedEntries=[];plannedEntries=[];settings={monthlyGoal:70,goalHasBeenSet:false}; if(monthlyGoalInput)monthlyGoalInput.value=settings.monthlyGoal;saveData();clearRecordForm();clearPlanForm();updateAllDisplays();showFeedback('feedback.clearAllDataSuccess','danger'); document.querySelectorAll('.card').forEach(c=>{if(c.id!=='record-card'&&c.classList.contains('expanded'))toggleCard(c);else if(c.id==='record-card'&&!c.classList.contains('expanded'))toggleCard(c);});});}
             function showConfirmationDialog(message, onConfirm) { if(dialogMessage)dialogMessage.textContent=message; currentConfirmCallback=onConfirm; confirmationDialog?.classList.add('visible'); dialogConfirmBtn?.focus(); }
             function hideConfirmationDialog() { confirmationDialog?.classList.remove('visible'); setTimeout(()=>{currentConfirmCallback=null;},300);}
             function showFeedback(key,type='info',vars={}) { let msg=t(key,vars); console.log(`Feedback[${type}]: ${msg}`); const fb=document.createElement('div'); fb.textContent=msg; fb.style.cssText = `position:fixed; bottom:20px; left:50%; transform:translateX(-50%); padding:10px 20px; border-radius:8px; z-index:1100; box-shadow:0 4px 15px rgba(0,0,0,0.2); font-size:0.95em; transition:opacity 0.5s ease, bottom 0.5s ease; opacity:0; background-color: ${type==='success'?'var(--success-color)':type==='danger'?'var(--danger-color)':'var(--primary-color)'}; color: var(--text-color);`; document.body.appendChild(fb); setTimeout(()=>{fb.style.opacity='1'; fb.style.bottom='30px';},10); setTimeout(()=>{fb.style.opacity='0'; fb.style.bottom='10px';},3500); setTimeout(()=>{fb.parentNode?.removeChild(fb)},4000);}

            // --- Display Update Functions (includes corrected date handling from previous step) ---
            function updateDashboard() {
                 const today = new Date();
                 const currentMonth = today.getMonth();
                 const currentYear = today.getFullYear();
                 let monthHours = 0, weekHours = 0;
                 const startOfWeekStr = getStartOfWeek(today);

                 recordedEntries.forEach(entry => {
                     const entryDate = parseLocalDate(entry.date);
                     if (isNaN(entryDate.valueOf())) return;

                     if (entryDate.getMonth() === currentMonth && entryDate.getFullYear() === currentYear) {
                         monthHours += entry.hours;
                     }
                     if (entry.date >= startOfWeekStr) {
                         weekHours += entry.hours;
                     }
                 });

                 if(dashboardWeekHours)dashboardWeekHours.textContent=formatHoursExtensive(weekHours);
                 const goal=settings.monthlyGoal||70;
                 const percentage = goal > 0 ? Math.min(100, (monthHours / goal) * 100) : 0;
                 if(dashboardMonthPercentage)dashboardMonthPercentage.textContent=`${Math.round(percentage)}%`;
                 updateProgressRing(monthHours, goal);
                 if(dashboardMonthTotal)dashboardMonthTotal.innerHTML=`${t('dashboard.monthTotalLabel')} <strong>${formatHoursExtensive(monthHours)}</strong>`;

                 const lastDayOfMonthObj = new Date(currentYear, currentMonth + 1, 0);
                 const lastDayOfMonth = lastDayOfMonthObj.getDate();
                 const todayDay = today.getDate();

                 const remainingDays = Math.max(0, lastDayOfMonth - todayDay);
                 const remainingHoursNeeded = Math.max(0, goal - monthHours);
                 let forecastText = '';

                 if (!settings.goalHasBeenSet) {
                    forecastText = `<span>${t('dashboard.setGoalPrompt')}</span>`;
                 } else if (remainingHoursNeeded <= 0) {
                    forecastText = `<span>${t('dashboard.goalMet')}</span>`;
                 } else if (remainingDays <= 0 && todayDay === lastDayOfMonth) {
                    forecastText = `<span>${t('dashboard.goalNotMetMonthEnd')}</span>`;
                 } else if (remainingDays <= 0) {
                     forecastText = `<span>${t('dashboard.forecastPrefix')} ${formatHoursExtensive(remainingHoursNeeded)}.</span>`;
                 } else {
                    let avgNeededPerDay = remainingHoursNeeded / remainingDays;
                    let daysToWork = remainingDays;
                    if (avgNeededPerDay > 0 && avgNeededPerDay < MIN_HOURS_PER_DAY_FORECAST) {
                        daysToWork = Math.ceil(remainingHoursNeeded / MIN_HOURS_PER_DAY_FORECAST);
                        avgNeededPerDay = MIN_HOURS_PER_DAY_FORECAST;
                    }
                    const daysSuffix = t(daysToWork === 1 ? 'dashboard.forecastSuffixDaysSingular' : 'dashboard.forecastSuffixDaysPlural');
                    const suggestion = `${t('dashboard.attemptPrefix')}<strong>${formatHoursExtensive(avgNeededPerDay, true)}</strong> ${t('dashboard.perDay')} ${daysToWork} ${daysSuffix}.`;
                    forecastText = `<span>${t('dashboard.forecastPrefix')} ${formatHoursExtensive(remainingHoursNeeded)}.</span><span>${suggestion}</span>`;
                 }
                 if(dashboardForecast) dashboardForecast.innerHTML = forecastText;

                 updateDashboardPlannedDates();
             }
            function updateProgressRing(cV, mV) { const p=mV>0?Math.min(100,(cV/mV)*100):0; const off=progressRingCircumference*(1-p/100); if(progressRingFg){progressRingFg.style.strokeDasharray=`${progressRingCircumference} ${progressRingCircumference}`; progressRingFg.style.strokeDashoffset=Math.max(0,off);}}
            function updateDashboardPlannedDates() {
                 const todayStr = getCurrentDateString();
                 const now = new Date();
                 const currentHour = now.getHours();
                 const overdueHourThreshold = 18;

                 const pastDuePlans = plannedEntries
                     .filter(p => p.date < todayStr)
                     .sort((a, b) => a.date.localeCompare(b.date));
                 const upcomingPlans = plannedEntries
                     .filter(p => p.date >= todayStr)
                     .sort((a, b) => a.date.localeCompare(b.date));

                 const displayPlans = upcomingPlans.slice(0, 3);
                 if (displayPlans.length < 3) {
                     const neededFromPast = 3 - displayPlans.length;
                     const recentPastDue = pastDuePlans.slice(-neededFromPast);
                     displayPlans.unshift(...recentPastDue);
                 }

                 if (dashboardPlanList) dashboardPlanList.innerHTML = '';
                 if (displayPlans.length > 0) {
                     dashboardPlannedDatesContainer?.classList.remove('hidden');
                     displayPlans.forEach(p => {
                         const li = document.createElement('li');
                         li.dataset.id = p.id;
                         let planText = `<strong>${formatRelativeDate(p.date)}:</strong> ${formatHoursExtensive(p.hours)}`;
                         const isPastDate = p.date < todayStr;
                         const isTodayPastThreshold = p.date === todayStr && currentHour >= overdueHourThreshold;
                         if (isPastDate || isTodayPastThreshold) {
                             planText += `<span class="plan-warning"> ${t('dashboard.overduePlanSuffix')}</span>`;
                         }
                         li.innerHTML = planText;
                         dashboardPlanList?.appendChild(li);
                     });
                 } else {
                     dashboardPlannedDatesContainer?.classList.add('hidden');
                 }
             }
             function renderHistory() {
                if (!historyList) return;
                historyList.innerHTML='';
                const searchTerm = historySearchInput?.value.trim().toLowerCase()||'';
                let results = [];
                let labelText = '';
                const hasSearch = searchTerm.length > 0;

                if (hasSearch) {
                    results = recordedEntries.filter(e => {
                        const tagInternal = e.tag || DEFAULT_TAG_VALUE;
                        const tagTranslated = t(tagKeyMapping[tagInternal] || 'tags.noTag').toLowerCase();
                        const formattedDate = formatDisplayDate(e.date).toLowerCase();
                        const hoursStr = (e.hours || 0).toString().replace('.', ',');
                        const hoursRoundedStr = Math.round(e.hours || 0).toString();
                        const hoursFormatted = formatHoursExtensive(e.hours).toLowerCase();
                        const notes = (e.notes || '').toLowerCase();
                        return (formattedDate.includes(searchTerm) || hoursStr.includes(searchTerm) || hoursRoundedStr.includes(searchTerm) || tagTranslated.includes(searchTerm) || notes.includes(searchTerm) || hoursFormatted.includes(searchTerm) || tagInternal.toLowerCase().includes(searchTerm));
                    });
                    const countKey = results.length === 1 ? 'historyCard.resultsCountForTermSingular' : 'historyCard.resultsCountForTermPlural';
                    labelText = t(countKey, { count: results.length, term: searchTerm });
                } else {
                    const dateLimitStr = getDateMonthsAgo(HISTORY_MONTH_LIMIT);
                    results = recordedEntries.filter(e => e.date >= dateLimitStr);
                    if (recordedEntries.length === 0) { labelText = t('historyCard.listPlaceholderNoRecords'); }
                    else if (results.length === 0) { labelText = t('historyCard.noRecordsLastMonths', { limit: HISTORY_MONTH_LIMIT }); }
                    else { labelText = t('historyCard.showingLastMonths', { limit: HISTORY_MONTH_LIMIT }); }
                }

                if (showingResultsLabel) showingResultsLabel.textContent = labelText;
                if (results.length === 0) {
                    let placeholderKey = 'historyCard.listPlaceholderNoRecords';
                    if (recordedEntries.length > 0) { placeholderKey = hasSearch ? 'historyCard.listPlaceholderNoSearchResults' : 'historyCard.listPlaceholderNoRecent'; }
                    if (historyListPlaceholder) { historyListPlaceholder.textContent = t(placeholderKey); historyListPlaceholder.classList.remove('hidden'); }
                } else {
                    historyListPlaceholder?.classList.add('hidden');
                    // Results should already be sorted DESC by date from loadData/handleRecordSubmit
                    results.forEach(e => {
                         const li = document.createElement('li'); li.dataset.id = e.id;
                         const tagInternal = e.tag || DEFAULT_TAG_VALUE; const tagText = t(tagKeyMapping[tagInternal] || 'tags.noTag'); const tagBadge = `<span class="tag-badge" ${tagInternal===DEFAULT_TAG_VALUE?'style="opacity:0.6;"':''}>${tagText}</span>`; const notesPreview = e.notes ? `<span class="notes-preview">${e.notes.replace(/\n/g,' ')}</span>` : `<span class="notes-preview" style="opacity:0.5;">${t('historyCard.noNotes')}</span>`; const hoursFormatted = formatHoursExtensive(e.hours);
                         li.innerHTML = `<div class="entry-details"><strong>${formatDisplayDate(e.date)}:</strong> <span class="hours">${hoursFormatted}</span> ${tagBadge} ${notesPreview}</div> <div class="entry-actions"><button class="edit-btn secondary">${t('common.editButton')}</button> <button class="delete-btn danger">${t('common.deleteButton')}</button></div>`;
                         li.querySelector('.edit-btn')?.addEventListener('click', ev => {ev.stopPropagation(); editRecordEntry(e.id);}); li.querySelector('.delete-btn')?.addEventListener('click', ev => {ev.stopPropagation(); deleteRecordEntry(e.id);}); historyList.appendChild(li);
                     });
                }
             }
            function renderPlanning() {
                 if(!planningList) return;
                 planningList.innerHTML='';
                 const todayStr = getCurrentDateString();
                 const allPlans = [...plannedEntries]; // Already sorted ASC by date from loadData/handlePlanSubmit
                 if(allPlans.length===0){ if(planningListPlaceholder){ planningListPlaceholder.textContent=t('planCard.listPlaceholderNoPastOrFuture'); planningListPlaceholder.classList.remove('hidden');} return;}
                 planningListPlaceholder?.classList.add('hidden');
                 allPlans.forEach(p=>{
                     const li=document.createElement('li'); li.dataset.id=p.id; const hoursDisplay = formatHoursExtensive(p.hours); const isPast = p.date < todayStr; const pastDateSuffix = isPast ? `<span style="opacity:0.7;margin-left:5px;">${t('planCard.pastDateSuffix')}</span>`:'';
                     li.innerHTML = `<div class="entry-details"><strong>${formatDisplayDate(p.date)} (${formatRelativeDate(p.date)}):</strong> <span class="hours">${hoursDisplay}</span> ${pastDateSuffix}</div><div class="plan-actions"><button class="done-plan-btn success">${t('planCard.markDoneButton')}</button> <button class="delete-plan-btn danger">${t('common.deleteButton')}</button></div>`;
                     li.querySelector('.done-plan-btn')?.addEventListener('click',e=>{e.stopPropagation();markPlanAsDone(p.id);}); li.querySelector('.delete-plan-btn')?.addEventListener('click',e=>{e.stopPropagation();deletePlanEntry(p.id);}); planningList.appendChild(li);
                 });
             }
             function updateStatistics() {
                const today = new Date(); const currentMonth = today.getMonth(); const currentYear = today.getFullYear(); let totalHoursMonth = 0; const activeDays = new Set();
                recordedEntries.filter(e => { const d = parseLocalDate(e.date); if (isNaN(d.valueOf())) return false; return d.getMonth() === currentMonth && d.getFullYear() === currentYear; }).forEach(e => { totalHoursMonth += e.hours; activeDays.add(e.date); });
                const goal = settings.monthlyGoal || 70; const percentProgress = settings.goalHasBeenSet ? (goal > 0 ? Math.min(Math.round((totalHoursMonth / goal) * 100), 100) : 0) : 0; const daysActiveCount = activeDays.size; const avgHoursPerActiveDay = daysActiveCount > 0 ? (totalHoursMonth / daysActiveCount) : 0;
                if (statsMonthHours) statsMonthHours.textContent = formatHoursExtensive(totalHoursMonth); if (statsMonthGoalProgress) statsMonthGoalProgress.textContent = settings.goalHasBeenSet ? `${percentProgress}%` : '--%'; if (statsMonthProgressBar) statsMonthProgressBar.style.width = `${percentProgress}%`; if (statsAvgHoursDay) statsAvgHoursDay.textContent = formatHoursExtensive(avgHoursPerActiveDay); if (statsMonthDaysActive) statsMonthDaysActive.textContent = daysActiveCount;
             }
            function populateMonthSelector() {
                if (!chartMonthSelector) return; const availableMonths = new Set();
                recordedEntries.forEach(e => { const dateObj = parseLocalDate(e.date); if (!isNaN(dateObj.valueOf())) { availableMonths.add(getMonthYearString(dateObj)); } });
                const sortedMonths = Array.from(availableMonths).sort((a, b) => { const [mA, yA] = a.split('/').map(Number); const [mB, yB] = b.split('/').map(Number); return (yB - yA) || (mB - mA); });
                const oldSelectedValue = chartMonthSelector.value; chartMonthSelector.innerHTML = '';
                if (sortedMonths.length === 0) { const option = document.createElement('option'); option.value = ''; option.textContent = t('chartsCard.noDataOption'); chartMonthSelector.append(option); chartMonthSelector.disabled = true; return; }
                chartMonthSelector.disabled = false; const currentMonthStr = getMonthYearString(new Date()); let currentMonthFormatted = formatMonthYearExtensive(currentMonthStr); let hasCurrentMonthData = false; let didSelectOldValue = false;
                sortedMonths.forEach(monthYearValue => { const option = document.createElement('option'); let monthFormatted = formatMonthYearExtensive(monthYearValue); option.value = monthYearValue; option.textContent = monthFormatted || monthYearValue; if (monthYearValue === oldSelectedValue) { option.selected = true; didSelectOldValue = true; } else if (monthYearValue === currentMonthStr && !didSelectOldValue) { option.selected = true; } if (monthYearValue === currentMonthStr) { hasCurrentMonthData = true; } chartMonthSelector.append(option); });
                if (!hasCurrentMonthData && currentMonthFormatted && Array.isArray(MONTH_NAMES) && MONTH_NAMES.length > 0) { const option = document.createElement('option'); option.value = currentMonthStr; option.textContent = `${currentMonthFormatted} ${t('chartsCard.currentMonthSuffix')}`; chartMonthSelector.insertBefore(option, chartMonthSelector.firstChild); if (!didSelectOldValue && !chartMonthSelector.querySelector('option[selected]')) { option.selected = true; } }
                 if (!chartMonthSelector.value && chartMonthSelector.options.length > 0) { chartMonthSelector.options[0].selected = true; }
             }
            function renderCharts(selectedMonthYear) {
                 if (monthlyHoursChartInstance) { monthlyHoursChartInstance.destroy(); monthlyHoursChartInstance = null; } if (!selectedMonthYear) { clearChartWithMessage(t('chartsCard.selectMonthMessage')); return; }
                 try {
                     const [selectedMonth, selectedYear] = selectedMonthYear.split('/').map(Number); const monthIndex = selectedMonth - 1;
                     const entriesForMonth = recordedEntries.filter(e => { const d = parseLocalDate(e.date); if (isNaN(d.valueOf())) return false; return d.getMonth() === monthIndex && d.getFullYear() === selectedYear; });
                     if (entriesForMonth.length === 0) { clearChartWithMessage(t('chartsCard.noRecordsInMonthMessage', { month: formatMonthYearExtensive(selectedMonthYear) })); return; }
                     let totalHours = 0; const hoursByTag = {};
                     entriesForMonth.forEach(e => { const tagName = e.tag || DEFAULT_TAG_VALUE; const hours = e.hours || 0; totalHours += hours; hoursByTag[tagName] = (hoursByTag[tagName] || 0) + hours; });
                     if (chartTotalHoursDisplay) chartTotalHoursDisplay.innerHTML = `${t('chartsCard.totalHoursLabel')} <strong>${formatHoursExtensive(totalHours)}</strong>`;
                     const labels = Object.keys(hoursByTag).map(tagName => t(tagKeyMapping[tagName] || 'tags.noTag')); const values = Object.values(hoursByTag); const backgroundColors = labels.map((_, i) => chartColors[i % chartColors.length]);
                     if (!monthlyHoursChartCtx) return;
                     monthlyHoursChartInstance = new Chart(monthlyHoursChartCtx, {
                         type: 'pie', data: { labels: labels, datasets: [{ data: values, backgroundColor: backgroundColors, borderColor: tooltipBgColor || '#1c1c1e', borderWidth: 1.5 }] },
                         options: { responsive: true, maintainAspectRatio: false, plugins: { title: { display: true, text: t('chartsCard.percentageDistributionTitle'), color: textMutedColor, font: { size: 12, weight: 'normal' }, padding: { bottom: 15 } }, tooltip: { backgroundColor: tooltipBgColor, titleColor: textColor, bodyColor: textColor, displayColors: true, padding: 10, cornerRadius: 6, callbacks: { label: ctx => { const label = ctx.label || ''; const value = ctx.parsed || 0; const percentage = totalHours > 0 ? ((value / totalHours) * 100).toFixed(1) : 0; return `${label}: ${formatHoursExtensive(value)} (${percentage}%)`; } } }, legend: { position: 'bottom', align: 'center', labels: { color: textMutedColor, boxWidth: 12, padding: 15 } } } }
                     });
                 } catch (e) { console.error("Chart render err:", e); clearChartWithMessage(t('chartsCard.renderErrorMessage')); }
            }
            function clearChartWithMessage(msg) { if(monthlyHoursChartInstance){monthlyHoursChartInstance.destroy();monthlyHoursChartInstance=null;} if(chartTotalHoursDisplay)chartTotalHoursDisplay.textContent=''; const ctx=monthlyHoursChartCtx; if(ctx){ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height); ctx.save(); ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillStyle=textMutedColor; ctx.font=`14px ${computedStyles?.fontFamily||'sans-serif'}`; ctx.fillText(msg,ctx.canvas.width/2,ctx.canvas.height/2); ctx.restore();}}
            function updateAllDisplays() { if(typeof t!=='function'||!translations?.[currentLang]){console.warn("Skip update: Translations not ready"); return;} try{applyStaticTranslations();updateDashboard();updateStatistics();populateMonthSelector();renderHistory();renderPlanning(); const selVal=chartMonthSelector?.value; if(!chartMonthSelector?.disabled && selVal)renderCharts(selVal); else if (!chartMonthSelector?.disabled && chartMonthSelector?.options?.length>0 && chartMonthSelector.options[0]?.value){chartMonthSelector.options[0].selected=true; renderCharts(chartMonthSelector.options[0].value);} else clearChartWithMessage(t(recordedEntries.length===0?'chartsCard.noDataYetMessage':'chartsCard.selectMonthMessage'));}catch(err){console.error("UpdateAll err:",err);}}
             function formatTimeInputOnType(event) { const i=event.target;let v=i.value,op=i.selectionStart,n=v.replace(/[^\d]/g,'').substring(0,4),f=n;let ca=false;if(n.length>2){const hp=n.substring(0,n.length-2),mp=n.substring(n.length-2);f=`${hp}:${mp}`;if(v.length<f.length&&v.indexOf(':')===-1)ca=true;}if(i.value!==f){i.value=f;let np=op;if(ca&&op>=f.indexOf(':')+1)np++;np=Math.min(np,f.length);requestAnimationFrame(()=>{try{i.setSelectionRange(np,np);}catch(e){}});}}
             function registerServiceWorker() { if('serviceWorker'in navigator)window.addEventListener('load',()=>{navigator.serviceWorker.register('./service-worker.js').then(r=>console.log('SW ok:',r.scope)).catch(e=>console.error('SW fail:',e));});}


            // --- Initialization Sequence (unchanged from previous correct step) ---
            loadData();
            applyStaticTranslations();
            if (monthlyGoalInput) monthlyGoalInput.value = settings.monthlyGoal;
            if (recordDateInput) recordDateInput.value = getCurrentDateString();
            setDateInputVisibility(false);
            clearRecordForm();
            clearPlanForm();
            document.querySelectorAll('.card').forEach(card => { const shouldBeExpanded = (card.id === 'record-card'); if (card.classList.contains('expanded') !== shouldBeExpanded) toggleCard(card); const icon = card.querySelector('.toggle-icon'); if (icon) icon.textContent = shouldBeExpanded ? '▲' : '▼'; });
            appElement?.addEventListener('click', (e) => { const h = e.target.closest('.card-header'); if (h) toggleCard(h.closest('.card')); });
            document.querySelectorAll('.card-header').forEach(h=>{h.setAttribute('role','button');h.setAttribute('tabindex','0');h.addEventListener('keydown',e=>{if(e.key==='Enter'||e.key===' ') {e.preventDefault();toggleCard(h.closest('.card'));}});});
            changeDateBtn?.addEventListener('click',()=>setDateInputVisibility(true)); recordHoursInput?.addEventListener('input',formatTimeInputOnType); planHoursInput?.addEventListener('input',formatTimeInputOnType);
             // --- Corrected Event Listeners using the restored functions ---
            recordHoursInput?.addEventListener('blur',e=>{ const d=parseTimeInputToDecimal(e.target.value); /* Use restored function */ if(!isNaN(d)&&d>=0)e.target.value=formatDecimalToTimeInput(d); else if(e.target.value.trim()!=='')e.target.value='';});
            planHoursInput?.addEventListener('blur',e=>{ const d=parseTimeInputToDecimal(e.target.value); /* Use restored function */ if(!isNaN(d)&&d>0)e.target.value=formatDecimalToTimeInput(d); else if(e.target.value.trim()!=='')e.target.value='';});
            // --- End corrected listeners ---
            recordNotesInput?.addEventListener('input',e=>{if(e.target.value.length>NOTES_MAX_LENGTH){e.target.value=e.target.value.substring(0,NOTES_MAX_LENGTH);showFeedback('feedback.notesLengthLimit','info',{maxLength:NOTES_MAX_LENGTH});}});
            historySearchInput?.addEventListener('input',renderHistory); recordForm?.addEventListener('submit',handleRecordSubmit); planForm?.addEventListener('submit',handlePlanSubmit);
            clearPlanFormBtn?.addEventListener('click',clearPlanForm); saveGoalBtn?.addEventListener('click',handleGoalSave);
            monthlyGoalInput?.addEventListener('keypress',e=>{if(e.key==='Enter'){e.preventDefault();handleGoalSave();e.target.blur();}});
            chartMonthSelector?.addEventListener('change',updateAllDisplays);
            clearAllDataBtn?.addEventListener('click',handleClearAllData);
            dialogConfirmBtn?.addEventListener('click',()=>{if(typeof currentConfirmCallback==='function')currentConfirmCallback(); hideConfirmationDialog();});
            dialogCancelBtn?.addEventListener('click',hideConfirmationDialog); confirmationDialog?.addEventListener('click',e=>{if(e.target===confirmationDialog)hideConfirmationDialog();});
            window.addEventListener('beforeinstallprompt',e=>{e.preventDefault(); deferredInstallPrompt=e; console.log('install prompt ready');});
            setInterval(updateDashboardPlannedDates, 60 * 1000);

            // Final steps
            updateAllDisplays();
            registerServiceWorker();
            if (!settings.goalHasBeenSet && !document.querySelector('.dialog-backdrop.visible')) {
                setTimeout(promptForMonthlyGoal, 600);
            }
            if (loadingIndicator) loadingIndicator.classList.add('hidden');
            console.log("App initialization complete.");

        })();
    </script>

</body>
</html>
