html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <!-- O title será definido pelo JS usando i18n -->
    <title>Loading...</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#0A84FF">
    <link rel="apple-touch-icon" href="icon-192x192.png">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <style>
        :root {
            --system-font: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            --primary-color: #0A84FF;
            --secondary-color: #000000;
            --card-bg: #1c1c1e;
            --input-bg: #2c2c2e;
            --text-color: #ffffff;
            --text-color-secondary: rgba(235, 235, 245, 0.6);
            --border-color: #3a3a3c;
            --shadow-color: rgba(0, 0, 0, 0.2);
            --danger-color: #FF453A;
            --success-color: #30D158;
            --placeholder-color: rgba(235, 235, 245, 0.3);
            --dialog-backdrop: rgba(0, 0, 0, 0.7);
            --progress-track-color: #38383a;
            --progress-bar-color: var(--success-color);
            --avg-line-color-1: #FF9F0A;
            --avg-line-color-2: #AF52DE;
            --avg-line-color-3: #5E5CE6;
            --font-family: var(--system-font);
            --border-radius: 10px;
            --card-padding: 18px;
            --outer-padding: 15px;
            --transition-speed: 0.3s;
            --transition-speed-fast: 0.1s;
            --content-transition: max-height 0.35s ease-out, opacity 0.25s ease-out 0.1s, padding 0.35s ease-out, margin 0.35s ease-out;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body { height: 100%; -webkit-tap-highlight-color: rgba(0,0,0,0); }
        body { font-family: var(--font-family); background-color: var(--secondary-color); color: var(--text-color); line-height: 1.5; padding: var(--outer-padding); overscroll-behavior-y: contain; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; font-size: 16px; }
        #dashboard-box { background-color: var(--card-bg); border-radius: var(--border-radius); padding: 15px var(--card-padding); margin-bottom: 20px; display: flex; justify-content: space-around; align-items: flex-start; text-align: center; gap: 15px; }
        .dashboard-item { position: relative; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; flex: 1; }
        .dashboard-item--progress { width: 90px; height: 90px; flex-shrink: 0; margin-top: 5px; }
        .progress-ring { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: rotate(-90deg); }
        .progress-ring__circle { fill: none; stroke-width: 5; transition: stroke-dashoffset 0.5s ease-out; }
        .progress-ring__bg { stroke: var(--progress-track-color); }
        .progress-ring__fg { stroke: var(--progress-bar-color); stroke-linecap: round; }
        .dashboard-item--progress .dashboard-content { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: flex; flex-direction: column; align-items: center; }
        #dashboard-month-percentage { font-size: 1.6em; color: var(--text-color); margin-bottom: 0; font-weight: 600;}
        .dashboard-item--progress .dashboard-label { margin-top: 2px; margin-bottom: 0; font-size: 0.65em; }
        .dashboard-label { font-size: 0.85em; color: var(--text-color-secondary); margin-bottom: 4px; display: block; }
        .dashboard-value { font-size: 1.4em; font-weight: 500; color: var(--primary-color); line-height: 1.2; margin-bottom: 5px; }
        .dashboard-value .unit { font-size: 0.6em; font-weight: 500; color: var(--text-color-secondary); margin-left: 2px; }
        #dashboard-summary { margin-top: 12px; font-size: 0.85em; color: var(--text-color-secondary); line-height: 1.35; text-align: left; width: 100%;}
        #dashboard-summary strong { color: var(--text-color); font-weight: 500; }
        #dashboard-summary span { display: block; margin-bottom: 3px;}
        #dashboard-planned-dates .dashboard-label { margin-bottom: 8px; margin-top: 15px; }
         #dashboard-plan-list { list-style: none; padding: 0; margin: 0; text-align: left; font-size: 0.8em; line-height: 1.4; color: var(--text-color-secondary); width: 100%; max-height: 60px; overflow: hidden; }
         #dashboard-plan-list li { margin-bottom: 3px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
         #dashboard-plan-list li strong { color: var(--text-color); }
         #dashboard-plan-list .plan-warning { font-size: 0.9em; margin-left: 5px; opacity: 0.7; font-style: italic; }
         .plan-past-date-indicator { font-size: 0.9em; opacity: 0.7; margin-left: 5px;}
        #app { max-width: 700px; margin: 0 auto; display: flex; flex-direction: column; gap: 12px; }
        h1 { display: none; }
        .card { background-color: var(--card-bg); border-radius: var(--border-radius); overflow: hidden; transition: box-shadow var(--transition-speed) ease; }
        .card-header { display: flex; justify-content: space-between; align-items: center; padding: 15px var(--card-padding); cursor: pointer; transition: background-color var(--transition-speed-fast) ease; position: relative; }
        .card-header::after { content: ''; position: absolute; bottom: 0; left: var(--card-padding); right: var(--card-padding); height: 1px; background-color: var(--border-color); opacity: 1; transition: opacity var(--transition-speed-fast) ease; }
        .card.expanded .card-header::after { opacity: 0; }
        .card:not(.expanded) .card-header:hover { background-color: rgba(255, 255, 255, 0.03); }
        .card-header h2 { color: var(--text-color); margin-bottom: 0; font-size: 1.15em; font-weight: 600; pointer-events: none; }
        .toggle-icon { font-size: 0.8em; font-weight: bold; transition: transform var(--transition-speed) ease; color: var(--text-color-secondary); margin-left: 10px; width: 20px; height: 20px; display: inline-flex; align-items: center; justify-content: center; pointer-events: none; }
        .card.expanded .toggle-icon { transform: rotate(180deg); }
        .card-content { padding: 0 var(--card-padding) 0 var(--card-padding); max-height: 0; opacity: 0; overflow: hidden; border-top: 1px solid var(--border-color); transition: var(--content-transition); margin-top: -1px; }
        .card.expanded .card-content { padding-top: var(--card-padding); padding-bottom: calc(var(--card-padding) + 5px); max-height: 1500px; opacity: 1; margin-top: 0; overflow: visible; }
        .form-group { margin-bottom: 16px; }
        label { display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-color-secondary); font-size: 0.9em; }
        input[type="date"], input[type="number"], input[type="text"], input[type="search"], textarea, select { width: 100%; padding: 11px 14px; border: 1px solid var(--border-color); border-radius: 8px; font-size: 1em; font-family: var(--font-family); transition: border-color var(--transition-speed) ease, box-shadow var(--transition-speed) ease; appearance: none; -webkit-appearance: none; -moz-appearance: none; background-color: var(--input-bg); color: var(--text-color); }
        input[type="text"].time-input { font-variant-numeric: tabular-nums; }
        input[type="search"] { padding-right: 35px; background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="rgba(235, 235, 245, 0.6)" class="bi bi-search" viewBox="0 0 16 16"><path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"/></svg>'); background-repeat: no-repeat; background-position: right 12px center; background-size: 16px 16px; }
        input[type="search"]::-webkit-search-cancel-button{ appearance: none; height: 14px; width: 14px; background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="rgba(235, 235, 245, 0.6)" class="bi bi-x-circle-fill" viewBox="0 0 16 16"><path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM5.354 4.646a.5.5 0 1 0-.708.708L7.293 8l-2.647 2.646a.5.5 0 0 0 .708.708L8 8.707l2.646 2.647a.5.5 0 0 0 .708-.708L8.707 8l2.647-2.646a.5.5 0 0 0-.708-.708L8 7.293 5.354 4.646z"/></svg>'); background-size: 14px 14px; cursor: pointer; }
        select { background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="rgba(235, 235, 245, 0.6)" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/></svg>'); background-repeat: no-repeat; background-position: right 14px center; background-size: 12px 12px; padding-right: 40px; }
        select:focus { background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="%230A84FF" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/></svg>'); }
        input[type="date"]::-webkit-calendar-picker-indicator { filter: invert(0.8); cursor: pointer; }
        input::placeholder, textarea::placeholder { color: var(--placeholder-color); opacity: 1; }
        input:focus, textarea:focus, select:focus { outline: none; border-color: var(--primary-color); box-shadow: 0 0 0 3px rgba(10, 132, 255, 0.3); }
        input[type="number"] { -moz-appearance: textfield; } input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        textarea { resize: vertical; min-height: 90px; }
        button { background-color: var(--primary-color); color: var(--text-color); border: none; padding: 11px 22px; border-radius: 8px; font-size: 1em; font-weight: 600; cursor: pointer; transition: background-color var(--transition-speed-fast) ease, transform var(--transition-speed-fast) ease, filter var(--transition-speed-fast) ease; display: inline-block; margin-right: 8px; margin-top: 10px; width: auto; transform: scale(1); filter: brightness(1); -webkit-user-select: none; user-select: none; }
        button:hover { filter: brightness(1.15); }
        button:active { transform: scale(0.95); filter: brightness(0.8); transition-duration: 0.05s; }
        button.secondary { background-color: var(--input-bg); color: var(--primary-color); border: 1px solid var(--border-color); } button.secondary:hover { background-color: #3a3a3c; filter: none; } button.secondary:active { background-color: #48484a; transform: scale(0.96); filter: brightness(1); }
        button.success { background-color: var(--success-color); color: var(--text-color); } button.success:hover { filter: brightness(1.15); } button.success:active { transform: scale(0.95); filter: brightness(0.8); }
        button.danger { background-color: var(--danger-color); color: var(--text-color); } button.danger:hover { background-color: #ff3b30; filter: brightness(1.15); } button.danger:active { background-color: #E0352D; transform: scale(0.96); filter: brightness(0.85); }
        #record-form .text-center button, #plan-form .text-center button { width: auto; margin-right: 8px; }
         #record-form .text-center button:last-child { margin-right: 0; }
         /* Ajuste específico para botões do plano em telas maiores, se necessário */
         @media (min-width: 600px) { /* Mantido para consistência, mas pode não ser mais necessário com as mudanças globais */ }
        .change-date-button { background: none; border: none; color: var(--primary-color); cursor: pointer; font-size: 0.9em; padding: 5px 0; margin-left: 5px; text-align: left; width: auto; margin-right: 0; margin-top: 0; } .change-date-button:hover { text-decoration: underline; } .change-date-button:active { transform: scale(0.95); filter: brightness(0.8); }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 12px; text-align: center; margin-top: 10px;}
        .stat-item { background-color: var(--input-bg); padding: 16px 12px; border-radius: 8px; }
        .stat-value { font-size: 1.7em; font-weight: 600; color: var(--text-color); display: block; margin-bottom: 2px; }
        .stat-label { font-size: 0.85em; color: var(--text-color-secondary); }
        .progress-bar-container { background-color: var(--border-color); border-radius: 5px; overflow: hidden; height: 8px; margin-top: 8px; }
        .progress-bar { background-color: var(--progress-bar-color); height: 100%; width: 0; transition: width var(--transition-speed) ease-out; }
        #history-controls { margin-bottom: 15px; display: flex; gap: 10px; padding: 0 var(--card-padding) }
        .history-search-input { flex-grow: 1; }
        #showing-results-label { font-size: 0.85em; color: var(--text-color-secondary); margin-top: 5px; display: block; text-align: right; padding: 0 var(--card-padding) 5px var(--card-padding) ; min-height: 1.2em;}
        .data-list { list-style: none; padding: 0; max-height: 400px; overflow-y: auto; margin-top: 0; }
        .data-list li { background-color: transparent; border-bottom: 1px solid var(--border-color); padding: 14px var(--card-padding); margin: 0; display: flex; justify-content: space-between; align-items: flex-start; flex-wrap: wrap; transition: background-color var(--transition-speed-fast) ease; }
        .data-list li:last-child { border-bottom: none; }
        .data-list li:hover { background-color: rgba(255, 255, 255, 0.02); }
        .entry-details { font-size: 0.95em; flex-grow: 1; margin-right: 10px; line-height: 1.4; padding-bottom: 5px; }
        .entry-details strong { color: var(--text-color); font-weight: 500; }
        .entry-details .hours { color: var(--primary-color); font-weight: 600; margin-left: 5px; margin-right: 5px; }
        .entry-details .tag-badge { display: inline-block; background-color: var(--input-bg); color: var(--text-color-secondary); font-size: 0.75em; padding: 2px 6px; border-radius: 5px; margin-left: 8px; vertical-align: middle; }
        .entry-details .notes-preview { color: var(--text-color-secondary); font-size: 0.9em; display: block; margin-top: 5px; white-space: normal; overflow-wrap: break-word; max-height: 4.5em; overflow: hidden; }
        .entry-actions { flex-shrink: 0; align-self: center; }
        .entry-actions button, .plan-actions button { padding: 6px 10px; font-size: 0.85em; margin-left: 5px; margin-top: 0; width: auto; border-radius: 6px; }
        .plan-actions button { margin-top: 5px; }
        .entry-actions button.secondary, .plan-actions button.secondary { background-color: #3a3a3c; }
        .chart-container { position: relative; height: 280px; width: 100%; margin-top: 25px; }
        .dialog-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--dialog-backdrop); display: flex; justify-content: center; align-items: center; z-index: 1000; opacity: 0; visibility: hidden; transition: opacity var(--transition-speed) ease, visibility var(--transition-speed) ease; }
        .dialog-backdrop.visible { opacity: 1; visibility: visible; }
        .dialog-content { background-color: #2c2c2e; color: var(--text-color); padding: 25px; border-radius: 14px; box-shadow: 0 8px 30px rgba(0,0,0,0.4); text-align: center; max-width: 90%; width: 320px; transform: scale(0.95); transition: transform var(--transition-speed) ease; }
        .dialog-backdrop.visible .dialog-content { transform: scale(1); }
        .dialog-content p { margin-bottom: 25px; font-size: 1.05em; line-height: 1.5; }
        .dialog-actions button { width: calc(50% - 5px); margin-top: 0; padding: 10px; font-size: 1em;}
        .hidden { display: none !important; }
        .visually-hidden { position: absolute; width: 1px; height: 1px; margin: -1px; padding: 0; overflow: hidden; clip: rect(0, 0, 0, 0); border: 0; }
        .text-center { text-align: center; } .mt-1 { margin-top: 10px; } .mt-2 { margin-top: 20px; }

        /* ===== ESTILOS PARA TELAS GRANDES (DESKTOP) ===== */
        @media (min-width: 992px) {
            body {
                padding: calc(var(--outer-padding) * 2); /* Mais espaço nas laterais */
            }
            #app {
                max-width: 1200px; /* Aumenta a largura máxima do conteúdo */
                gap: 20px; /* Mais espaçamento entre os cards */
            }
            #dashboard-box {
                padding: 20px calc(var(--card-padding) * 1.5); /* Mais padding interno no dashboard */
                gap: 25px;
                margin-bottom: 25px;
            }
             .dashboard-label {
                 font-size: 0.9em;
             }
             .dashboard-value {
                 font-size: 1.6em;
             }
             #dashboard-month-percentage {
                font-size: 1.8em;
             }
             .dashboard-item--progress {
                 width: 100px;
                 height: 100px;
             }
             #dashboard-summary {
                 font-size: 0.9em;
             }
            .card {
                /* Faz os cards estarem expandidos por padrão */
                margin-bottom: 5px; /* Pequeno ajuste para compensar a remoção da borda no header */
            }
            .card .card-header {
                 cursor: default; /* Remove o cursor de ponteiro já que não é mais clicável para expandir */
                 /* pointer-events: none; Desativar? Não, alguns botões podem estar no header */
            }
            .card .card-header:hover {
                 background-color: transparent; /* Remove o hover no header */
            }
            .card .card-header::after {
                opacity: 0; /* Oculta a linha divisória do header */
            }
            .card .card-content {
                 /* Aplica os estilos de 'expanded' diretamente */
                 max-height: 1500px; /* Ou um valor suficientemente grande */
                 opacity: 1;
                 padding-top: var(--card-padding);
                 padding-bottom: calc(var(--card-padding) + 5px);
                 margin-top: 0;
                 overflow: visible; /* Ou auto se necessário */
                 border-top: 1px solid var(--border-color); /* Adiciona borda que estava faltando no header fechado */
             }
            .card .toggle-icon {
                 display: none; /* Oculta o ícone de toggle */
            }
            .chart-container {
                 height: 350px; /* Gráfico maior em desktop */
                 margin-top: 30px;
            }
            .data-list {
                max-height: 500px; /* Histórico pode ser maior */
            }
            /* Poderíamos adicionar mais ajustes aqui: fontes maiores, layouts de grid mais complexos, etc. */
            #plan-form .text-center {
                 /* Talvez alinhar botões diferente? Ex: à direita */
                 /* text-align: right; */
            }
            .dialog-content {
                 width: 400px; /* Diálogo um pouco maior */
             }
        }

    </style>
</head>
<body>
    <!-- Dashboard (Textos já usam translate key ou são valores dinâmicos) -->
    <div id="dashboard-box">
         <div class="dashboard-item" style="align-items: flex-start; text-align: left;">
             <span class="dashboard-label" data-translate-key="dashboardWeekHoursLabel"></span>
             <span id="dashboard-week-hours" class="dashboard-value">0 hours</span> <!-- Valor dinâmico -->
              <div id="dashboard-summary" style="margin-top: 12px;">
                 <!-- O JS insere os valores aqui -->
                 <span id="dashboard-month-total"><span data-translate-key="dashboardMonthLabel"></span>: <strong>0 hours</strong></span> <!-- Valor dinâmico -->
                 <span id="dashboard-forecast"><span data-translate-key="dashboardForecastLabel"></span>: ...</span> <!-- Conteúdo dinâmico -->
             </div>
             <div class="hidden" id="dashboard-planned-dates">
                <!-- A visibilidade e o label são controlados pelo JS/CSS -->
                <span class="dashboard-label" style="margin-top: 15px;" data-translate-key="dashboardPlannedDatesLabel"></span>
                <ul id="dashboard-plan-list">
                    <!-- Conteúdo dinâmico gerado pelo JS -->
                </ul>
             </div>
         </div>
         <div class="dashboard-item dashboard-item--progress">
            <svg viewBox="0 0 36 36" class="progress-ring">
                 <circle class="progress-ring__circle progress-ring__bg" cx="18" cy="18" r="15.9155"></circle>
                 <circle id="progress-ring-fg" class="progress-ring__circle progress-ring__fg" cx="18" cy="18" r="15.9155" stroke-dasharray="100 100" stroke-dashoffset="100"></circle>
            </svg>
            <div class="dashboard-content">
                <span id="dashboard-month-percentage" class="dashboard-value">0%</span> <!-- Valor dinâmico -->
                <span class="dashboard-label" data-translate-key="dashboardMonthGoalLabel"></span>
             </div>
         </div>
    </div>

    <div id="app">
        <!-- Card Registro (Expandido por padrão em mobile também, toggle inverte isso) -->
        <div class="card expanded" id="record-card">
             <!-- A classe 'expanded' inicial pode ser mantida ou removida dependendo se você quer começar expandido em mobile -->
             <div class="card-header" role="button" tabindex="0">
                 <h2 data-translate-key="recordActivityTitle"></h2>
                 <span class="toggle-icon">▲</span> <!-- Conteúdo alterado pelo JS -->
             </div>
            <div class="card-content">
                <form id="record-form">
                    <input type="hidden" id="record-id">
                    <div class="form-group">
                        <!-- A label externa agora está escondida visualmente quando a data é alterável -->
                        <label for="record-date" id="date-label">
                             <span data-translate-key="recordDateLabel"></span>: <strong id="display-date" data-translate-key="displayDateToday"></strong> <!-- JS define "Hoje" ou a data -->
                            <button type="button" class="change-date-button" id="change-date-btn" data-translate-key="changeDateButton"></button>
                        </label>
                        <!-- Input de data começa escondido -->
                        <input type="date" id="record-date" class="hidden">
                    </div>
                     <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                         <div class="form-group">
                             <label for="record-hours" data-translate-key="recordTimeLabel"></label>
                             <input type="text" inputmode="numeric" id="record-hours" class="time-input" required data-translate-placeholder-key="recordTimePlaceholder">
                         </div>
                        <div class="form-group">
                            <label for="record-tag" data-translate-key="recordModeLabel"></label>
                            <!-- Opções terão texto definido pelo JS/i18n -->
                            <select id="record-tag">
                                <option value="Casa em casa" selected data-translate-key="recordTagOptionHouseToHouse"></option>
                                <option value="Carrinho" data-translate-key="recordTagOptionCart"></option>
                                <option value="Cartas" data-translate-key="recordTagOptionLetters"></option>
                                <option value="Telefone" data-translate-key="recordTagOptionPhone"></option>
                                <option value="Outro" data-translate-key="recordTagOptionOther"></option>
                            </select>
                        </div>
                     </div>
                    <div class="form-group">
                        <label for="record-notes" data-translate-key="recordNotesLabel"></label> <!-- JS já adicionava "(max 300)"? Se não, a chave precisa incluir. -->
                        <textarea id="record-notes" rows="3" maxlength="300" data-translate-placeholder-key="recordNotesPlaceholder"></textarea>
                    </div>
                    <div class="text-center" style="margin-top: 20px;">
                        <!-- Texto do botão será "Salvar" ou "Atualizar" via JS/i18n -->
                        <button type="submit" id="save-record-btn" data-translate-key="saveRecordButton"></button>
                    </div>
                </form>
            </div>
        </div>

        <!-- Card Planejar -->
        <div class="card" id="plan-card">
             <div class="card-header" role="button" tabindex="0">
                <h2 data-translate-key="planHoursTitle"></h2>
                <span class="toggle-icon">▼</span> <!-- Conteúdo alterado pelo JS -->
             </div>
             <div class="card-content">
                 <form id="plan-form">
                    <input type="hidden" id="plan-id">
                    <div class="form-group">
                      <label for="plan-date" data-translate-key="planDateLabel"></label>
                      <input type="date" id="plan-date" required>
                    </div>
                    <div class="form-group">
                       <label for="plan-hours" data-translate-key="planHoursLabel"></label> <!-- "(HH:MM)" precisa estar na tradução -->
                       <input type="text" inputmode="numeric" id="plan-hours" class="time-input" required data-translate-placeholder-key="planHoursPlaceholder">
                    </div>
                    <div class="text-center">
                      <button type="submit" id="save-plan-btn" data-translate-key="savePlanButton"></button>
                      <button type="button" id="clear-plan-form-btn" class="secondary" data-translate-key="clearPlanFormButton"></button>
                    </div>
                </form>
                <div id="planning-list-container" class="mt-2">
                    <!-- Texto do H3 precisa de chave. Estilo inline pode ser mantido ou movido para CSS -->
                    <h3 style="font-size: 1em; font-weight: 600; color: var(--text-color-secondary); margin-bottom: 10px; padding-left: var(--card-padding);" data-translate-key="planningListTitle"></h3>
                    <ul id="planning-list" class="data-list">
                        <!-- Placeholder com chave -->
                        <li class="placeholder hidden" style="padding-left: var(--card-padding);" data-translate-key="planningListPlaceholder"></li>
                        <!-- Conteúdo dinâmico gerado pelo JS -->
                    </ul>
                </div>
             </div>
        </div>

        <!-- Card Estatísticas -->
        <div class="card" id="stats-card">
            <div class="card-header" role="button" tabindex="0">
                <h2 data-translate-key="detailedSummaryTitle"></h2>
                <span class="toggle-icon">▼</span> <!-- Conteúdo alterado pelo JS -->
             </div>
             <div class="card-content">
                 <div class="form-group" style="max-width: 200px; margin: 0 auto 25px auto; text-align:center;">
                   <label for="monthly-goal" data-translate-key="monthlyGoalLabel"></label> <!-- "(Horas)" precisa estar na tradução -->
                   <input type="number" id="monthly-goal" min="1" step="1" value="70"> <!-- Valor inicial pode ser mantido ou ajustado pelo JS ao carregar settings -->
                   <button id="save-goal-btn" class="mt-1 secondary" style="width:100%; font-size:0.9em; padding: 8px 10px;" data-translate-key="setGoalButton"></button>
                 </div>
                 <div class="stats-grid">
                    <!-- Todos os textos aqui são via translate-key ou valores dinâmicos -->
                    <div class="stat-item">
                        <span id="stats-month-hours" class="stat-value">0</span>
                        <span class="stat-label" data-translate-key="statsMonthHoursLabel"></span>
                    </div>
                    <div class="stat-item">
                        <span id="stats-month-goal-progress" class="stat-value">0%</span>
                        <span class="stat-label" data-translate-key="statsGoalProgressLabel"></span>
                        <div class="progress-bar-container"><div id="stats-month-progress-bar" class="progress-bar"></div></div>
                    </div>
                    <div class="stat-item">
                        <span id="stats-avg-hours-day" class="stat-value">0</span>
                        <span class="stat-label" data-translate-key="statsAvgHoursDayLabel"></span>
                    </div>
                    <div class="stat-item">
                        <span id="stats-month-days-active" class="stat-value">0</span>
                        <span class="stat-label" data-translate-key="statsMonthDaysActiveLabel"></span>
                    </div>
                 </div>
             </div>
        </div>

        <!-- Card Gráficos -->
        <div class="card" id="charts-card">
            <div class="card-header" role="button" tabindex="0">
                 <h2 data-translate-key="hoursChartTitle"></h2>
                 <span class="toggle-icon">▼</span> <!-- Conteúdo alterado pelo JS -->
             </div>
             <div class="card-content">
                 <div class="form-group">
                    <label for="chart-month-selector" data-translate-key="viewMonthLabel"></label>
                    <!-- Opções preenchidas dinamicamente pelo JS com meses traduzidos -->
                    <select id="chart-month-selector">
                    </select>
                 </div>
                 <div class="chart-container">
                    <canvas id="monthlyHoursChart"></canvas>
                 </div>
             </div>
        </div>

        <!-- Card Histórico -->
        <div class="card" id="history-card">
            <div class="card-header" role="button" tabindex="0">
                <h2 data-translate-key="historyTitle"></h2>
                <span class="toggle-icon">▼</span> <!-- Conteúdo alterado pelo JS -->
            </div>
             <div class="card-content">
                 <div id="history-controls">
                    <input type="search" id="history-search-input" class="history-search-input" data-translate-placeholder-key="historySearchPlaceholder">
                 </div>
                 <!-- Span preenchido dinamicamente pelo JS -->
                 <span id="showing-results-label"></span>
                 <ul id="history-list" class="data-list">
                     <!-- Placeholder com chave -->
                    <li class="placeholder hidden" style="padding-left: var(--card-padding);" data-translate-key="historyNoRecordsYet"></li>
                    <!-- Itens de histórico (incluindo botões 'Editar'/'Deletar') gerados dinamicamente pelo JS com textos via i18n -->
                 </ul>
            </div>
        </div>

        <!-- Card Configurações -->
        <div class="card" id="settings-card">
            <div class="card-header" role="button" tabindex="0">
                <h2 data-translate-key="settingsTitle"></h2>
                <span class="toggle-icon">▼</span> <!-- Conteúdo alterado pelo JS -->
            </div>
            <div class="card-content">
                <div class="text-center">
                  <button id="clear-all-data-btn" class="danger" data-translate-key="clearAllDataButton"></button>
                </div>
                <!-- Parágrafo de aviso com chave -->
                <p style="margin-top: 15px; font-size: 0.9em; color: var(--text-color-secondary); text-align: center; line-height: 1.4;" data-translate-key="clearDataWarning"></p>
            </div>
        </div>
    </div>

    <!-- Diálogo de Confirmação -->
    <div id="confirmation-dialog" class="dialog-backdrop">
      <div class="dialog-content">
         <!-- Mensagem definida dinamicamente, mas a chave pode ser usada para um padrão -->
         <p id="dialog-message" data-translate-key="dialogConfirmMessageDefault"></p> <!-- Use uma chave padrão se necessário -->
         <div class="dialog-actions">
            <button id="dialog-confirm-btn" class="danger" data-translate-key="dialogConfirmButton"></button>
            <button id="dialog-cancel-btn" class="secondary" data-translate-key="dialogCancelButton"></button>
         </div>
       </div>
    </div>

    <!-- Script JS não modificado -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // ----- Configurações de Internacionalização (i18n) -----
            const i18n = {
                translations: {},
                supportedLanguages: ['pt-BR', 'en'],
                defaultLanguage: 'en',
                currentLanguage: 'en',
                translationsUrl: './translations.json',

                detectLanguage() {
                    const fullBrowserLang = navigator.language || navigator.userLanguage || this.defaultLanguage;
                    const baseBrowserLang = fullBrowserLang.split('-')[0];

                    if (this.supportedLanguages.includes(fullBrowserLang)) {
                        this.currentLanguage = fullBrowserLang;
                    } else if (this.supportedLanguages.includes(baseBrowserLang)) {
                        this.currentLanguage = baseBrowserLang;
                    } else if (this.supportedLanguages.some(lang => lang.startsWith(baseBrowserLang))) {
                        this.currentLanguage = this.supportedLanguages.find(lang => lang.startsWith(baseBrowserLang));
                    } else if (this.supportedLanguages.includes(this.defaultLanguage)) {
                        this.currentLanguage = this.defaultLanguage;
                    } else if (this.supportedLanguages.length > 0) {
                        this.currentLanguage = this.supportedLanguages[0];
                    } else {
                        this.currentLanguage = this.defaultLanguage;
                    }
                    console.log(`Browser language: ${fullBrowserLang}, Using language: ${this.currentLanguage}`);
                    document.documentElement.lang = this.currentLanguage;
                },

                async loadTranslations() {
                    try {
                        const response = await fetch(this.translationsUrl);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}, ao buscar ${this.translationsUrl}`);
                        }
                        this.translations = await response.json();
                        console.log('Translations loaded successfully.');
                        this.translations[this.defaultLanguage] = this.translations[this.defaultLanguage] || {};
                        this.translations[this.currentLanguage] = this.translations[this.currentLanguage] || this.translations[this.defaultLanguage];
                    } catch (error) {
                        console.error('Error loading translations:', error);
                        this.translations[this.defaultLanguage] = this.translations[this.defaultLanguage] || {};
                        this.translations[this.currentLanguage] = this.translations[this.currentLanguage] || this.translations[this.defaultLanguage];
                        showFeedback(`Error loading translations: ${error.message}. Falling back to ${this.currentLanguage}.`, 'danger');
                    }
                },

                t(key, replacements = {}) {
                    const langTranslations = this.translations[this.currentLanguage]
                                             || this.translations[this.defaultLanguage]
                                             || {};
                    let translation = langTranslations[key] || key; // Fallback to key name if not found

                    if (Array.isArray(translation)) {
                        return translation; // Return array as is (e.g., for month names)
                    }

                    if (typeof translation === 'string') {
                        // Basic placeholder replacement
                        for (const placeholder in replacements) {
                           // Use a simpler regex that works for basic {placeholder}
                           const regex = new RegExp(`\\{${placeholder}\\}`, 'g');
                           translation = translation.replace(regex, replacements[placeholder]);
                        }
                    } else {
                        console.warn(`Translation for key "${key}" is not a string or array:`, translation);
                        translation = key; // Use the key itself as fallback
                    }
                    return translation;
                },

                 applyTranslationsToDOM() {
                     // Set page title
                     document.title = this.t('appTitle', {}, 'Pioneer Tracker'); // Add default fallback title

                     // Handle elements with data-translate-key
                     document.querySelectorAll('[data-translate-key]').forEach(element => {
                         const key = element.getAttribute('data-translate-key');
                         const translation = this.t(key);
                         // Check if translation likely contains HTML
                         if (typeof translation === 'string' && /<[a-z][\s\S]*>/i.test(translation)) {
                            // Only use innerHTML if the translation contains HTML tags
                             element.innerHTML = translation;
                         } else if (element.tagName === 'BUTTON' || element.tagName === 'SPAN' || element.tagName === 'H2' || element.tagName === 'P' || element.tagName === 'STRONG' || element.tagName === 'LABEL' || element.tagName === 'H3' || element.tagName === 'LI' ) {
                             // For common text elements, set textContent
                             element.textContent = translation;
                         } else {
                             // Default or less common elements, also try textContent
                             element.textContent = translation;
                         }
                         // Handle specific case for the Change Date Button (might need visibility adjustment based on text)
                         if(element.id === 'change-date-btn' && translation === '') {
                            // If the translation for change date is empty maybe hide it? Or ensure it has a default
                            // element.style.display = 'none'; // Example
                         }
                     });

                     // Handle placeholders
                     document.querySelectorAll('[data-translate-placeholder-key]').forEach(element => {
                         const key = element.getAttribute('data-translate-placeholder-key');
                         element.placeholder = this.t(key);
                     });

                     // Handle titles (tooltips)
                     document.querySelectorAll('[data-translate-title-key]').forEach(element => {
                         const key = element.getAttribute('data-translate-title-key');
                         element.title = this.t(key);
                     });

                     // Special handling for toggle icons (up/down arrows)
                     document.querySelectorAll('.toggle-icon').forEach(icon => {
                          const card = icon.closest('.card');
                          const isExpanded = card ? card.classList.contains('expanded') : false;
                          // Ensure keys 'toggleIconCollapse' and 'toggleIconExpand' exist in your JSON
                          icon.textContent = isExpanded ? this.t('toggleIconCollapse', {}, '▲') : this.t('toggleIconExpand', {}, '▼');
                      });

                     // Special handling for select options
                     const tagSelect = document.getElementById('record-tag');
                     if(tagSelect) {
                          tagSelect.querySelectorAll('option[data-translate-key]').forEach(option => {
                              const key = option.getAttribute('data-translate-key');
                              option.textContent = this.t(key); // Set option text
                          });
                          // Optionally, set default value based on translated text if needed after loading
                          // const defaultTagKey = "recordTagOptionHouseToHouse";
                          // const defaultTagValue = this.t(defaultTagKey);
                          // This assumes the 'value' attribute matches the default language text, which might be okay
                          // tagSelect.value = "Casa em casa"; // Or set based on i18n default? Better handled by JS logic potentially.
                     }
                 }
            };

            // ----- Variáveis Globais e Seletores de Elementos -----
            let appElement, dashboardWeekHours, dashboardMonthPercentage, dashboardMonthTotal,
                dashboardForecast, dashboardPlannedDatesContainer, dashboardPlanList, progressRingFg,
                recordCard, recordForm, recordIdInput, recordDateInput, dateLabel, displayDate,
                changeDateBtn, recordHoursInput, recordTagSelect, recordNotesInput, saveRecordBtn,
                planCard, planForm, planIdInput, planDateInput, planHoursInput, savePlanBtn,
                clearPlanFormBtn, planningList, planningListPlaceholder, monthlyGoalInput, saveGoalBtn,
                statsMonthHours, statsMonthGoalProgress, statsMonthProgressBar, statsAvgHoursDay,
                statsMonthDaysActive, chartMonthSelector, monthlyHoursChartCtx, historyList,
                historySearchInput, historyListPlaceholder, showingResultsLabel, clearAllDataBtn,
                confirmationDialog, dialogMessage, dialogConfirmBtn, dialogCancelBtn,
                computedStyles, textColor, textMutedColor, gridColor, tooltipBgColor, primaryColor,
                avgLineColor1, avgLineColor2, avgLineColor3;

            let recordedEntries = [];
            let plannedEntries = [];
            let settings = { monthlyGoal: 70, goalHasBeenSet: false };
            let monthlyHoursChartInstance = null;
            let currentEditingId = null;
            let currentConfirmCallback = null;
            let isDateInputVisible = false;
            let deferredInstallPrompt = null;
            let progressRingRadius = 0;
            let progressRingCircumference = 0;

            // ----- Constantes -----
            const HISTORY_MONTH_LIMIT = 3;
            const NOTES_MAX_LENGTH = 300;
            const MIN_HOURS_PER_DAY_FORECAST = 1.0;
            const LOCAL_STORAGE_KEYS = {
                ENTRIES: 'pioneerTracker_entries_v5.2', // Mantido
                PLANS: 'pioneerTracker_plans_v1.2',     // Mantido
                SETTINGS: 'pioneerTracker_settings_v1.2' // Mantido
            };

            // ----- Funções Utilitárias -----
             // Helper function to replace placeholders like {name}
            function replacePlaceholders(text, replacements) {
                 if (typeof text !== 'string') return text; // Return original if not a string
                 let result = text;
                 for (const placeholder in replacements) {
                     // Basic regex to find {placeholder}
                     const regex = new RegExp(`\\{${placeholder}\\}`, 'g');
                     result = result.replace(regex, replacements[placeholder]);
                 }
                 return result;
            }

            function getCurrentDateString() { const t = new Date(); return `${t.getFullYear()}-${String(t.getMonth() + 1).padStart(2, '0')}-${String(t.getDate()).padStart(2, '0')}`; }
            function formatDisplayDate(dateString) { if (!dateString || !dateString.includes('-')) return dateString; const [y, m, d] = dateString.split('-'); return `${d}/${m}/${y}`; }
            function getMonthYearString(date) { const m = String(date.getMonth() + 1).padStart(2, '0'); const y = date.getFullYear(); return `${m}/${y}`; }
            function getStartOfWeek(date = new Date()) { const d = new Date(date); const dayOfWeek = d.getDay(); const diff = d.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1); const sOW = new Date(d.setDate(diff)); sOW.setHours(0, 0, 0, 0); return `${sOW.getFullYear()}-${String(sOW.getMonth() + 1).padStart(2, '0')}-${String(sOW.getDate()).padStart(2, '0')}`; }
            function getDateMonthsAgo(months) { const d = new Date(); d.setMonth(d.getMonth() - months); d.setHours(0, 0, 0, 0); return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`; }

            function formatMonthYearExtensive(monthYearString) {
                 if (!monthYearString || !monthYearString.includes('/')) return monthYearString;
                 const [m, y] = monthYearString.split('/');
                 const monthIndex = parseInt(m, 10) - 1;
                 if (monthIndex < 0 || monthIndex > 11) return monthYearString; // Invalid month index

                 // Get month names from i18n (ensure 'monthNames' key exists in JSON)
                 const monthNames = i18n.t('monthNames');
                 if (!Array.isArray(monthNames) || monthNames.length !== 12) {
                     console.warn("Month names ('monthNames') not available or invalid in translation.");
                     // Fallback to numerical format
                     return `${m}/${y}`;
                 }
                 return `${monthNames[monthIndex]} ${y}`;
            }

             // Formats decimal hours into a human-readable string using i18n for suffixes and structure
            function formatHoursExtensive(hoursDecimal, short = false) {
                 const zeroSuffix = short ? `0${i18n.t('hoursShortSuffix', {}, 'h')}` : `0 ${i18n.t('hoursSuffix', {}, 'hours')}`;
                 if (isNaN(hoursDecimal) || hoursDecimal < 0) return zeroSuffix;

                 const totalMinutes = Math.round((hoursDecimal || 0) * 60);
                 const hours = Math.floor(totalMinutes / 60);
                 const minutes = totalMinutes % 60;

                 if (hours === 0 && minutes === 0) return zeroSuffix;

                 const hSuffixKey = short ? 'hoursShortSuffix' : (hours === 1 ? 'hoursSuffixSingular' : 'hoursSuffix');
                 const mSuffixKey = short ? 'minutesShortSuffix' : (minutes === 1 ? 'minutesSuffixSingular' : 'minutesSuffix');

                 // Provide fallback defaults directly in t() calls
                 const hSuffix = i18n.t(hSuffixKey, {}, short ? 'h' : (hours === 1 ? 'hour' : 'hours'));
                 const mSuffix = i18n.t(mSuffixKey, {}, short ? 'm' : (minutes === 1 ? 'minute' : 'minutes'));
                 const connector = (hours > 0 && minutes > 0 && !short) ? i18n.t('connectorAnd', {}, ' and ') : ' ';

                 // Example 'hoursFormat' key could be "{hours}{hSuffix}{connector}{minutes}{mSuffix}"
                 const formatString = i18n.t('hoursFormat', {}, "{hours}{hSuffix}{connector}{minutes}{mSuffix}");

                 const replacements = {
                     hours: hours > 0 ? hours.toString() : '',
                     hSuffix: hours > 0 ? hSuffix : '',
                     connector: (hours > 0 && minutes > 0) ? connector : '', // Only add connector if both exist
                     minutes: minutes > 0 ? minutes.toString() : '',
                     mSuffix: minutes > 0 ? mSuffix : ''
                 };

                 let result = replacePlaceholders(formatString, replacements);

                 // Clean up extra spaces that might result from missing parts
                 result = result.replace(/\s+/g, ' ').trim();

                 return result || zeroSuffix; // Fallback if result ends up empty
             }


             // Parses time input (HH:MM, H:MM, MM, HMM, HHMM) to decimal hours
             function parseTimeInputToDecimal(timeString) {
                 if (!timeString) return 0;
                 const trimmed = String(timeString).trim();
                 if (!trimmed) return 0;

                 // Try HH:MM or H:MM format
                 const colonMatch = trimmed.match(/^(\d{1,3}):(\d{1,2})$/);
                 if (colonMatch) {
                     const hours = parseInt(colonMatch[1], 10);
                     const minutes = parseInt(colonMatch[2], 10);
                     // Basic validation
                     if (!isNaN(hours) && !isNaN(minutes) && minutes >= 0 && minutes < 60 && hours >= 0) {
                         return hours + (minutes / 60);
                     } else {
                         return NaN; // Invalid time format
                     }
                 }

                 // Try pure numeric input (MM, HMM, HHMM) - Max 4 digits (e.g., 1230 = 12h 30m)
                 const numberMatch = trimmed.match(/^(\d+)$/);
                 if (numberMatch) {
                    const numStr = numberMatch[1];
                    const numVal = parseInt(numStr, 10);
                    if (isNaN(numVal)) return NaN;

                    if (numStr.length <= 2) { // Assume minutes if 1 or 2 digits (e.g., 30 = 0h 30m)
                         if(numVal >= 0 && numVal < 60) { return numVal / 60; } // standard minutes
                         else if (numVal >= 60) { return numVal / 60; } // > 60 min, calc hours
                         else { return NaN;} // Invalid minutes
                     } else if (numStr.length >= 3 && numStr.length <= 4) { // Assume HMM or HHMM
                         const potentialHoursStr = numStr.slice(0, -2); // All but last 2 digits are hours
                         const potentialMinutesStr = numStr.slice(-2);  // Last 2 digits are minutes
                         const hours = parseInt(potentialHoursStr, 10);
                         const minutes = parseInt(potentialMinutesStr, 10);

                         if (!isNaN(hours) && !isNaN(minutes) && minutes >= 0 && minutes < 60 && hours >= 0) {
                             return hours + (minutes / 60);
                         } else {
                            return NaN; // Invalid format
                         }
                     } else { // Too many digits
                         return NaN;
                     }
                 }

                 // Could add support for '1.5h', '1h 30m' later if needed
                 return NaN; // Format not recognized
            }

            // Formats decimal hours back into HH:MM for input fields
            function formatDecimalToTimeInput(decimalHours) {
                if (isNaN(decimalHours) || decimalHours <= 0) return "";
                const totalMinutes = Math.round((decimalHours || 0) * 60);
                const hours = Math.floor(totalMinutes / 60);
                const minutes = totalMinutes % 60;
                return `${hours}:${String(minutes).padStart(2, '0')}`; // HH:MM format
            }

            function formatRelativeDate(dateString) {
                 const today = new Date();
                 today.setHours(0, 0, 0, 0);
                 const inputDate = new Date(dateString + 'T00:00:00'); // Ensure time is midnight UTC
                 if (isNaN(inputDate)) return formatDisplayDate(dateString); // Invalid date input

                 const tomorrow = new Date(today);
                 tomorrow.setDate(today.getDate() + 1);
                 const oneWeekFromToday = new Date(today);
                 oneWeekFromToday.setDate(today.getDate() + 7);

                 // Get weekday names from i18n (ensure 'weekdayNamesShort' key exists)
                 const weekdayNames = i18n.t('weekdayNamesShort');
                 if (!Array.isArray(weekdayNames) || weekdayNames.length !== 7) {
                     console.warn("Weekday names ('weekdayNamesShort') not available/invalid for relative date formatting.");
                     return formatDisplayDate(dateString); // Fallback
                 }

                 if (inputDate.getTime() === today.getTime()) {
                     return i18n.t('today', {}, 'Today'); // Ensure 'today' key exists
                 }
                 if (inputDate.getTime() === tomorrow.getTime()) {
                     return i18n.t('tomorrow', {}, 'Tomorrow'); // Ensure 'tomorrow' key exists
                 }
                 // Check if the date is within the next week (but not today or tomorrow)
                 if (inputDate > tomorrow && inputDate <= oneWeekFromToday) {
                    const weekday = weekdayNames[inputDate.getDay()]; // 0=Sun, 1=Mon,...
                     // Use a format string like 'nextWeekday': "Next {weekday}"
                     return i18n.t('nextWeekday', { weekday: weekday }, `Next ${weekday}`);
                 }

                 // Default: return the formatted date DD/MM/YYYY
                 return formatDisplayDate(dateString);
            }

             // Get default tag based on translation key
             function getDefaultTag() {
                 // Ensure 'recordTagOptionHouseToHouse' exists in translations
                 return i18n.t('recordTagOptionHouseToHouse', {}, 'House to house'); // Default value if key fails
             }

            // ----- Persistência -----
             function saveData() {
                 try {
                     localStorage.setItem(LOCAL_STORAGE_KEYS.ENTRIES, JSON.stringify(recordedEntries));
                     localStorage.setItem(LOCAL_STORAGE_KEYS.PLANS, JSON.stringify(plannedEntries));
                     localStorage.setItem(LOCAL_STORAGE_KEYS.SETTINGS, JSON.stringify(settings));
                     // console.log("Data saved successfully."); // Optional feedback
                 } catch (e) {
                     console.error("Error saving data to localStorage:", e);
                     // Use i18n for user feedback message
                     showFeedback(i18n.t('feedbackDataSaveFailed', {}, 'Error saving data! Changes might be lost.'), 'danger');
                 }
             }

             function loadData() {
                 try {
                    // Load Entries
                     let storedEntriesRaw = localStorage.getItem(LOCAL_STORAGE_KEYS.ENTRIES);
                     if (storedEntriesRaw) {
                         try {
                            const parsedEntries = JSON.parse(storedEntriesRaw);
                            // Basic validation: check if it's an array
                            if(Array.isArray(parsedEntries)) {
                                // Sanitize entries during load (e.g., ensure notes are strings, hours are numbers)
                                recordedEntries = parsedEntries.map(e => ({
                                     ...e,
                                     hours: Number(e.hours) || 0, // Ensure hours is a number
                                     notes: String(e.notes || '').substring(0, NOTES_MAX_LENGTH), // Ensure notes is string and limited
                                     tag: String(e.tag || '') // Ensure tag is a string
                                 }));
                            } else {
                                throw new Error("Stored entries data is not an array");
                            }
                         } catch (parseErr) {
                            console.error("Error parsing stored entries, resetting entries:", parseErr);
                             storedEntriesRaw = null; // Clear corrupted data indication
                             recordedEntries = [];
                             localStorage.removeItem(LOCAL_STORAGE_KEYS.ENTRIES); // Remove bad data
                         }
                     } else {
                         recordedEntries = []; // No data found
                     }
                     // Always sort after loading/initializing
                     recordedEntries.sort((a, b) => new Date(b.date + 'T00:00:00') - new Date(a.date + 'T00:00:00'));

                     // Load Plans
                     const storedPlansRaw = localStorage.getItem(LOCAL_STORAGE_KEYS.PLANS);
                     if (storedPlansRaw) {
                         try {
                             plannedEntries = JSON.parse(storedPlansRaw);
                             if (!Array.isArray(plannedEntries)) {
                                 console.error("Stored plans data is not an array, resetting plans.");
                                 plannedEntries = [];
                                 localStorage.removeItem(LOCAL_STORAGE_KEYS.PLANS);
                             } else {
                                 // Sanitize plans: ensure hours exist and are numbers, filter out invalid ones
                                 plannedEntries = plannedEntries.map(p => {
                                     // Compatibility: if old 'plannedHours' exists, rename to 'hours'
                                     if (p.plannedHours !== undefined && typeof p.plannedHours === 'number') {
                                         p.hours = p.plannedHours;
                                         delete p.plannedHours;
                                     }
                                     p.hours = Number(p.hours) || 0; // Ensure hours is a number
                                     return p;
                                 }).filter(p => p.date && p.hours > 0); // Keep only valid plans
                             }
                         } catch (parseErr) {
                             console.error("Error parsing stored plans, resetting plans:", parseErr);
                             plannedEntries = [];
                             localStorage.removeItem(LOCAL_STORAGE_KEYS.PLANS);
                         }
                     } else {
                         plannedEntries = [];
                     }
                      // Sort plans by date ascending
                      plannedEntries.sort((a, b) => new Date(a.date + 'T00:00:00') - new Date(b.date + 'T00:00:00'));


                     // Load Settings
                     const storedSettingsRaw = localStorage.getItem(LOCAL_STORAGE_KEYS.SETTINGS);
                     let loadedSettings = {};
                     if(storedSettingsRaw) {
                         try {
                            loadedSettings = JSON.parse(storedSettingsRaw);
                         } catch (parseErr) {
                             console.error("Error parsing stored settings, using defaults:", parseErr);
                             localStorage.removeItem(LOCAL_STORAGE_KEYS.SETTINGS);
                         }
                     }

                     // Define defaults and merge loaded settings
                      const defaultSettings = { monthlyGoal: 70, goalHasBeenSet: false };
                     settings = { ...defaultSettings, ...loadedSettings };

                     // Sanitize settings: ensure monthlyGoal is a positive number
                     settings.monthlyGoal = Number(settings.monthlyGoal);
                     if (isNaN(settings.monthlyGoal) || settings.monthlyGoal <= 0) {
                         settings.monthlyGoal = defaultSettings.monthlyGoal; // Reset to default if invalid
                     }
                      // Ensure goalHasBeenSet is boolean
                     if (typeof settings.goalHasBeenSet !== 'boolean') {
                         settings.goalHasBeenSet = !!settings.monthlyGoal; // Infer if it was likely set
                     }

                     console.log("Data loaded from localStorage.");

                 } catch (err) {
                     console.error("Critical error loading data from localStorage:", err);
                     // Reset all data to prevent inconsistent state
                     recordedEntries = [];
                     plannedEntries = [];
                     settings = { monthlyGoal: 70, goalHasBeenSet: false };
                     // Try to clear potentially corrupted localStorage
                     try {
                         localStorage.removeItem(LOCAL_STORAGE_KEYS.ENTRIES);
                         localStorage.removeItem(LOCAL_STORAGE_KEYS.PLANS);
                         localStorage.removeItem(LOCAL_STORAGE_KEYS.SETTINGS);
                     } catch (e) {
                         console.error("Error removing invalid storage items:", e);
                     }
                     // Notify user via i18n key
                     showFeedback(i18n.t('feedbackLoadError', {}, 'Error loading data. Application data has been reset.'), 'danger');
                 }
             }

            // ----- Instalação PWA -----
             function triggerInstallPromptIfAvailable(context = 'Context not specified') {
                 if (deferredInstallPrompt && settings.goalHasBeenSet) {
                     console.log(`Attempting to show install prompt (${context})...`);
                     // Add a slight delay to ensure UI updates are finished
                     setTimeout(() => {
                        deferredInstallPrompt.prompt();
                        // Wait for the user to respond to the prompt
                        deferredInstallPrompt.userChoice.then((choiceResult) => {
                            if (choiceResult.outcome === 'accepted') {
                                console.log('User accepted the install prompt');
                            } else {
                                console.log('User dismissed the install prompt');
                            }
                            deferredInstallPrompt = null; // Prompt can only be used once
                        }).catch(err => {
                            console.error("Error processing prompt userChoice:", err);
                            deferredInstallPrompt = null;
                        });
                    }, 500); // 500ms delay
                 } else if (!settings.goalHasBeenSet) {
                      console.log(`Install prompt not shown: Goal not set yet (${context}).`);
                 } else {
                      console.log(`Install prompt not available at this time (${context}). DeferredInstallPrompt: ${deferredInstallPrompt}`);
                 }
            }

            // ----- UI e Manipulação do DOM -----
             function promptForMonthlyGoal() {
                 let goalSet = false;
                 while (!goalSet) {
                    // Use i18n for prompt message and provide current goal as default
                    const goalInput = prompt(i18n.t('feedbackGoalPrompt', {}, 'Please set your monthly hour goal:'), settings.monthlyGoal);

                    if (goalInput === null) { // User cancelled
                        goalSet = true; // Exit loop
                        // If the goal was never *explicitly* set before, mark it as set now with the default
                        if (!settings.goalHasBeenSet) {
                            settings.goalHasBeenSet = true;
                            saveData(); // Save the state
                            updateAllDisplays(); // Update UI to reflect the default goal being active
                             console.log("User cancelled initial goal setting, using default goal.");
                        }
                    } else { // User entered something
                        const goalValue = parseInt(goalInput, 10);
                        // Validate input
                        if (!isNaN(goalValue) && goalValue > 0) {
                            settings.monthlyGoal = goalValue;
                            settings.goalHasBeenSet = true; // Mark as explicitly set
                             monthlyGoalInput.value = goalValue; // Update the input field in settings card
                             saveData(); // Persist the new goal
                             goalSet = true; // Exit loop
                             updateAllDisplays(); // Update UI
                             showFeedback(i18n.t('feedbackGoalSet', {}, 'Monthly goal set successfully!'), "success");
                            triggerInstallPromptIfAvailable('After setting initial goal via prompt'); // Check PWA install
                        } else {
                            // Use i18n for error alert
                             alert(i18n.t('feedbackGoalInvalid', {}, 'Invalid goal. Please enter a positive number.'));
                        }
                     }
                 }
             }

            function setDateInputVisibility(visible) {
                 isDateInputVisible = visible;
                 if (visible) {
                     recordDateInput.classList.remove('hidden');
                     dateLabel.classList.add('visually-hidden'); // Hide the static label part
                     recordDateInput.focus(); // Focus the input field
                 } else {
                     recordDateInput.classList.add('hidden');
                     dateLabel.classList.remove('visually-hidden'); // Show static label again
                     // Update the display text (e.g., "Today" or "DD/MM/YYYY")
                     const dateValue = recordDateInput.value;
                     const isToday = !dateValue || dateValue === getCurrentDateString();
                     // Use i18n for "Today" text
                      displayDate.textContent = isToday ? i18n.t('displayDateToday', {}, 'Today') : formatDisplayDate(dateValue);
                 }
            }

            function toggleCard(cardElement) {
                if (!cardElement) return;
                const isExpanded = cardElement.classList.contains('expanded');
                cardElement.classList.toggle('expanded', !isExpanded); // Toggle the class
                const icon = cardElement.querySelector('.toggle-icon');
                if (icon) {
                     // Update icon text using i18n keys
                    icon.textContent = !isExpanded ? i18n.t('toggleIconCollapse', {}, '▲') : i18n.t('toggleIconExpand', {}, '▼');
                }
            }

             // Resets the recording form to its initial state
            function clearRecordForm() {
                 recordForm.reset(); // Resets native form elements
                 recordIdInput.value = ''; // Clear hidden ID field
                 currentEditingId = null; // Reset editing state
                 recordDateInput.value = getCurrentDateString(); // Set date to today
                 setDateInputVisibility(false); // Show "Today" text, hide date input
                 recordTagSelect.value = getDefaultTag(); // Reset select to default (uses i18n)
                 recordNotesInput.value = ''; // Clear notes textarea
                 recordHoursInput.value = ''; // Clear time input

                 // Reset save button text using i18n
                 saveRecordBtn.textContent = i18n.t('saveRecordButton', {}, 'Save Record');
                 saveRecordBtn.classList.remove('editing'); // Remove any visual editing cues
            }

            function handleRecordSubmit(event) {
                event.preventDefault(); // Prevent default form submission

                 // Get and validate form data
                 const id = recordIdInput.value ? parseInt(recordIdInput.value, 10) : Date.now(); // Use existing ID or generate new one
                const date = recordDateInput.value || getCurrentDateString(); // Get date, default to today
                const hoursInput = recordHoursInput.value;
                 const hours = parseTimeInputToDecimal(hoursInput); // Parse HH:MM to decimal
                const tag = recordTagSelect.value || getDefaultTag(); // Get selected tag or default
                const notes = recordNotesInput.value.trim().substring(0, NOTES_MAX_LENGTH); // Get notes, trim, and limit length

                 // --- Input Validation ---
                 if (isNaN(hours) || hours <= 0) {
                     alert(i18n.t('feedbackTimeInvalid', {}, 'Please enter a valid time (e.g., 1:30 or 90 for 1 hour 30 minutes).'));
                     recordHoursInput.focus();
                     return;
                 }
                 if (!date) { // Should typically not happen with default, but check anyway
                    alert(i18n.t('feedbackDateInvalid', {}, 'Please select a valid date.'));
                     // If date input isn't visible, show it for correction
                     if (!isDateInputVisible) setDateInputVisibility(true);
                     recordDateInput.focus();
                     return;
                 }

                 // Create entry object
                 const newEntry = { id, date, hours, tag, notes };

                 // Check if editing or adding new
                 const existingIndex = recordedEntries.findIndex(entry => entry.id === id);
                 if (existingIndex > -1) { // Editing existing
                     recordedEntries[existingIndex] = newEntry;
                 } else { // Adding new
                     recordedEntries.push(newEntry);
                 }

                 // Keep entries sorted by date descending
                 recordedEntries.sort((a, b) => new Date(b.date + 'T00:00:00') - new Date(a.date + 'T00:00:00'));

                 saveData(); // Persist changes
                 clearRecordForm(); // Reset the form
                 updateAllDisplays(); // Update UI (dashboard, history, stats, etc.)
                 showFeedback(i18n.t('feedbackRecordSaved', {}, 'Record saved successfully!'), 'success');
            }

            function editRecordEntry(id) {
                 const entry = recordedEntries.find(e => e.id === id);
                 if (entry) {
                     // Expand card if collapsed
                    if (!recordCard.classList.contains('expanded')) {
                         toggleCard(recordCard);
                     }

                     // Set editing state
                     currentEditingId = id;

                     // Populate form fields
                     recordIdInput.value = entry.id;
                     recordDateInput.value = entry.date;
                      // Show date input only if the date is not today
                      setDateInputVisibility(entry.date !== getCurrentDateString());
                     recordHoursInput.value = formatDecimalToTimeInput(entry.hours); // Format back to HH:MM
                     recordTagSelect.value = entry.tag || getDefaultTag(); // Set tag or default
                     recordNotesInput.value = entry.notes || ''; // Set notes

                     // Update save button text using i18n
                     saveRecordBtn.textContent = i18n.t('updateRecordButton', {}, 'Update Record');
                     saveRecordBtn.classList.add('editing'); // Add visual cue for editing

                     // Scroll to the form and focus on hours input for quick editing
                     recordCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
                     setTimeout(() => recordHoursInput.focus(), 300); // Delay focus slightly for scroll
                 } else {
                      console.warn("Record entry not found for editing:", id);
                       // Optionally show feedback if entry not found
                       showFeedback(i18n.t('feedbackEntryNotFound', {}, 'Record not found.'), 'danger');
                 }
            }

            function deleteRecordEntry(id) {
                 // Use i18n for confirmation message
                 showConfirmationDialog(i18n.t('feedbackDeleteRecordConfirm', {}, 'Are you sure you want to delete this record? This cannot be undone.'), () => {
                    const index = recordedEntries.findIndex(e => e.id === id);
                    if (index > -1) {
                        recordedEntries.splice(index, 1); // Remove the entry
                         saveData(); // Persist changes
                         updateAllDisplays(); // Update UI
                         showFeedback(i18n.t('feedbackRecordDeleted', {}, 'Record deleted.'), 'info');

                         // If the deleted entry was being edited, clear the form
                         if (currentEditingId === id) {
                             clearRecordForm();
                         }
                     } else {
                          console.warn("Record entry not found for deletion:", id);
                          // Optional: show error feedback if somehow entry disappeared
                           showFeedback(i18n.t('feedbackEntryNotFound', {}, 'Record not found for deletion.'), 'danger');
                    }
                });
            }

             // Clears the planning form
             function clearPlanForm() {
                 planForm.reset(); // Reset native form fields
                 planIdInput.value = ''; // Clear hidden ID
                 currentEditingId = null; // Reset any editing state specific to plans if needed
                 planDateInput.value = ''; // Clear date input
                 planHoursInput.value = ''; // Clear hours input

                 // Reset save button text using i18n (assuming it could change for editing plans)
                 savePlanBtn.textContent = i18n.t('savePlanButton', {}, 'Save Plan');
                 // clearPlanFormBtn. // Might want to reset its state too if applicable
            }

            function handlePlanSubmit(event) {
                 event.preventDefault();

                 // Get plan data
                 const id = planIdInput.value ? parseInt(planIdInput.value, 10) : Date.now(); // Reuse ID or create new
                 const date = planDateInput.value;
                 const hoursInput = planHoursInput.value;
                 const hours = parseTimeInputToDecimal(hoursInput);
                 const todayStr = getCurrentDateString(); // For validation

                 // Validation
                 if (!date || isNaN(hours) || hours <= 0) {
                     alert(i18n.t('feedbackPlanInvalid', {}, 'Please enter a valid future date and planned time.'));
                     if (!date) planDateInput.focus(); else planHoursInput.focus();
                     return;
                 }
                 if (date < todayStr) {
                     alert(i18n.t('feedbackPlanDatePast', {}, 'Planned date cannot be in the past.'));
                     planDateInput.focus();
                     return;
                 }

                 // Create or update plan object
                 const newPlan = { id, date, hours };
                 const existingIndex = plannedEntries.findIndex(p => p.id === id);

                 if (existingIndex > -1) { // Updating existing plan
                     plannedEntries[existingIndex] = newPlan;
                 } else { // Adding new plan
                     plannedEntries.push(newPlan);
                 }

                 // Keep plans sorted by date ascending
                 plannedEntries.sort((a, b) => new Date(a.date + 'T00:00:00') - new Date(b.date + 'T00:00:00'));

                 saveData();
                 clearPlanForm();
                 updateAllDisplays(); // Update dashboard and planning list
                 showFeedback(i18n.t('feedbackPlanSaved', {}, 'Plan saved successfully!'), 'success');
             }


             // Moves a planned entry to recorded entries
            function markPlanAsDone(id) {
                const planIndex = plannedEntries.findIndex(p => p.id === id);
                 if (planIndex === -1) {
                     console.error("Plan not found to mark as done:", id);
                     showFeedback(i18n.t('feedbackPlanNotFound', {}, 'Planned entry not found.'), 'danger');
                     return;
                 }

                const plan = plannedEntries[planIndex];
                 const todayStr = getCurrentDateString();

                 // Decide the date for the record: use plan date if past, otherwise use today's date
                const recordDate = new Date(plan.date + 'T00:00:00') < new Date(todayStr + 'T00:00:00') ? plan.date : todayStr;

                 // Create a new record entry based on the plan
                const newRecordEntry = {
                    id: Date.now(), // Generate a new unique ID for the record
                    date: recordDate,
                     hours: plan.hours,
                     tag: getDefaultTag(), // Use the default tag (e.g., "House to house")
                     // Add a note indicating it came from a past plan using i18n
                     notes: i18n.t('planNoteFromPastPlan', { date: formatDisplayDate(plan.date) }, `From plan dated ${formatDisplayDate(plan.date)}`)
                };

                 // Add the new record
                recordedEntries.push(newRecordEntry);
                 // Sort records again
                recordedEntries.sort((a, b) => new Date(b.date + 'T00:00:00') - new Date(a.date + 'T00:00:00'));

                 // Remove the plan from the planned list
                plannedEntries.splice(planIndex, 1);

                saveData();
                 updateAllDisplays(); // Update dashboard, history, stats, planning list
                showFeedback(i18n.t('feedbackPlanMarkedDone', {}, 'Plan marked as done and recorded.'), 'success');
             }

             function deletePlanEntry(id) {
                 // Use i18n for confirmation message
                 showConfirmationDialog(i18n.t('feedbackDeletePlanConfirm', {}, 'Are you sure you want to delete this plan?'), () => {
                     const initialLength = plannedEntries.length;
                     plannedEntries = plannedEntries.filter(p => p.id !== id); // Filter out the plan

                     if (plannedEntries.length < initialLength) { // Check if something was actually deleted
                         saveData();
                         updateAllDisplays();
                         showFeedback(i18n.t('feedbackPlanDeleted', {}, 'Plan deleted.'), 'info');

                         // If the deleted plan was being edited (if plan editing form exists), clear the form
                         if (currentEditingId === id && planIdInput.value == id) { // Ensure it's the correct form being cleared
                            clearPlanForm();
                        }
                     } else {
                         console.warn("Plan entry not found for deletion:", id);
                         showFeedback(i18n.t('feedbackPlanNotFound', {}, 'Planned entry not found.'), 'danger');
                     }
                 });
            }

            function handleGoalSave() {
                const newGoal = parseInt(monthlyGoalInput.value, 10);
                if (!isNaN(newGoal) && newGoal > 0) {
                    // Only save and update if the goal actually changed
                     if(settings.monthlyGoal !== newGoal) {
                        settings.monthlyGoal = newGoal;
                        settings.goalHasBeenSet = true; // Mark as explicitly set/updated
                         saveData(); // Persist the change
                         updateAllDisplays(); // Update dashboard, stats, etc.
                         showFeedback(i18n.t('feedbackGoalUpdated', {}, 'Monthly goal updated!'), 'success');
                        triggerInstallPromptIfAvailable('After updating goal in settings card'); // Check PWA install
                     }
                } else {
                    alert(i18n.t('feedbackGoalInvalid', {}, 'Invalid goal. Please enter a positive number.'));
                    // Restore the input field to the currently saved goal
                    monthlyGoalInput.value = settings.monthlyGoal;
                }
            }

            function handleClearAllData() {
                 // Use i18n for confirmation, make it very clear!
                 showConfirmationDialog(i18n.t('feedbackClearAllConfirm', {}, 'DANGER: Are you sure you want to delete ALL records, plans, and settings? This action cannot be undone!'), () => {
                     // Reset in-memory data
                     recordedEntries = [];
                     plannedEntries = [];
                      // Reset settings to defaults
                      const defaultSettings = { monthlyGoal: 70, goalHasBeenSet: false };
                     settings = { ...defaultSettings };

                      // Update settings input field
                     monthlyGoalInput.value = settings.monthlyGoal;

                      saveData(); // Overwrite localStorage with empty/default data

                      // Clear forms
                     clearRecordForm();
                     clearPlanForm();

                     updateAllDisplays(); // Update UI to reflect cleared state

                     // Provide strong feedback using i18n
                     showFeedback(i18n.t('feedbackDataCleared', {}, 'All application data has been cleared!'), 'danger');

                    // Optional: Collapse cards other than the first one after clearing
                    document.querySelectorAll('.card').forEach(c => {
                        const shouldBeExpanded = (c.id === 'record-card'); // Keep record card potentially expanded
                        if (c.classList.contains('expanded') !== shouldBeExpanded) {
                           // Check if toggleCard is safe to call without user interaction context in all browsers
                           // For simplicity, directly set class based on desktop or mobile view might be better
                           // Or just collapse all non-record cards.
                            if (!shouldBeExpanded && c.classList.contains('expanded')) {
                                toggleCard(c); // Only collapse if needed
                            }
                        }
                     });
                 });
            }


            function showConfirmationDialog(message, onConfirm) {
                // Ensure message is a string
                dialogMessage.textContent = String(message);
                 currentConfirmCallback = onConfirm; // Store the function to call on confirm
                 confirmationDialog.classList.add('visible'); // Make the dialog visible
                dialogConfirmBtn.focus(); // Focus the confirm button for accessibility
            }

            function hideConfirmationDialog() {
                confirmationDialog.classList.remove('visible');
                // Clear callback after transition to prevent accidental calls
                setTimeout(() => {
                    currentConfirmCallback = null;
                    dialogMessage.textContent = ''; // Clear message text
                }, 300); // Match CSS transition duration
            }

             // Shows temporary feedback messages at the bottom of the screen
            function showFeedback(message, type = 'info') {
                console.log(`Feedback[${type}]: ${message}`); // Log feedback for debugging

                const feedbackElement = document.createElement('div');
                feedbackElement.textContent = message;

                // Basic styling (could be moved to CSS classes)
                 feedbackElement.style.position = 'fixed';
                 feedbackElement.style.bottom = '-60px'; // Start off-screen
                 feedbackElement.style.left = '50%';
                 feedbackElement.style.transform = 'translateX(-50%)';
                 feedbackElement.style.padding = '12px 25px';
                 feedbackElement.style.borderRadius = 'var(--border-radius, 10px)';
                 feedbackElement.style.zIndex = '1100';
                 feedbackElement.style.boxShadow = '0 5px 20px rgba(0,0,0,0.25)';
                 feedbackElement.style.fontSize = '1em';
                 feedbackElement.style.textAlign = 'center';
                 feedbackElement.style.maxWidth = 'calc(100% - 30px)'; // Prevent full width on small screens
                 feedbackElement.style.transition = 'opacity 0.4s ease, bottom 0.4s ease';
                 feedbackElement.style.opacity = '0';
                feedbackElement.style.fontFamily = 'var(--system-font)';
                feedbackElement.style.pointerEvents = 'none'; // Prevent interaction

                // Apply type-specific background/color using CSS variables
                switch (type) {
                     case 'success':
                         feedbackElement.style.backgroundColor = 'var(--success-color, #30D158)';
                         feedbackElement.style.color = '#ffffff';
                         break;
                     case 'danger':
                         feedbackElement.style.backgroundColor = 'var(--danger-color, #FF453A)';
                         feedbackElement.style.color = '#ffffff';
                         break;
                     case 'info':
                     default:
                         feedbackElement.style.backgroundColor = 'var(--primary-color, #0A84FF)';
                         feedbackElement.style.color = '#ffffff';
                         break;
                 }

                 document.body.appendChild(feedbackElement);

                 // Animate in
                 setTimeout(() => {
                     feedbackElement.style.opacity = '1';
                     feedbackElement.style.bottom = '20px';
                 }, 10); // Short delay before animation starts

                 // Animate out and remove
                 setTimeout(() => {
                     feedbackElement.style.opacity = '0';
                     feedbackElement.style.bottom = '-60px';
                 }, 3500); // Start fading out after 3.5 seconds

                 // Remove from DOM after fade out animation
                 setTimeout(() => {
                     if (feedbackElement.parentNode) {
                         feedbackElement.parentNode.removeChild(feedbackElement);
                     }
                 }, 4000); // Remove after 4 seconds (3500 + 400ms transition + buffer)
             }


            function updateDashboard() {
                const today = new Date();
                const currentMonth = today.getMonth();
                const currentYear = today.getFullYear();
                 const startOfWeekStr = getStartOfWeek(today); // Monday of the current week
                 const todayStr = getCurrentDateString();

                let monthHours = 0;
                let weekHours = 0;

                 // Calculate hours for the current month and week
                recordedEntries.forEach(entry => {
                    const entryDate = new Date(entry.date + 'T00:00:00');
                    if (entryDate.getMonth() === currentMonth && entryDate.getFullYear() === currentYear) {
                        monthHours += entry.hours;
                    }
                     // Check if entry date is within the current week (Monday to Today)
                    if (entry.date >= startOfWeekStr && entry.date <= todayStr) {
                        weekHours += entry.hours;
                    }
                });

                 // Update dashboard elements using i18n for formatting
                dashboardWeekHours.textContent = formatHoursExtensive(weekHours);

                 // Calculate goal progress
                const goal = settings.monthlyGoal;
                const percent = goal > 0 ? Math.min(100, (monthHours / goal) * 100) : 0;
                 dashboardMonthPercentage.textContent = `${Math.round(percent)}%`;
                updateProgressRing(monthHours, goal); // Update the visual ring

                 // Update month total display
                 dashboardMonthTotal.querySelector('strong').textContent = formatHoursExtensive(monthHours);

                // Update forecast
                 const lastDayOfMonth = new Date(currentYear, currentMonth + 1, 0).getDate(); // Days in current month
                 const todayDayOfMonth = today.getDate();
                 const remainingDays = Math.max(0, lastDayOfMonth - todayDayOfMonth); // Days left *including* today? Check logic maybe +1? No, this seems right.
                const remainingHours = Math.max(0, goal - monthHours);
                 let forecastText = '';
                 // Use i18n for the label part
                 const forecastLabelSpan = `<span data-translate-key="dashboardForecastLabel">${i18n.t('dashboardForecastLabel', {}, 'Forecast')}</span>: `;

                 if (!settings.goalHasBeenSet) {
                     forecastText = forecastLabelSpan + i18n.t('dashboardGoalNotSet', {}, 'Set a goal first');
                 } else if (remainingHours <= 0) {
                     forecastText = forecastLabelSpan + i18n.t('dashboardGoalReached', {}, 'Goal reached!');
                 } else if (remainingDays <= 0 && monthHours < goal) { // Month ended, goal not met
                     forecastText = forecastLabelSpan + i18n.t('dashboardGoalNotReached', {}, 'Goal not reached this month');
                 } else { // Calculate average needed
                     let avgNeeded = remainingDays > 0 ? remainingHours / remainingDays : remainingHours; // Avg needed per remaining day
                     let daysToReachGoal = remainingDays;

                      // Adjust forecast if average is very low, aim for a minimum reasonable daily rate
                     if (daysToReachGoal > 0 && avgNeeded > 0 && avgNeeded < MIN_HOURS_PER_DAY_FORECAST) {
                         daysToReachGoal = Math.ceil(remainingHours / MIN_HOURS_PER_DAY_FORECAST); // How many days if doing minimum
                         avgNeeded = MIN_HOURS_PER_DAY_FORECAST; // Suggest the minimum rate
                     } else if (daysToReachGoal <= 0) { // Should only happen on last day if not met
                        avgNeeded = remainingHours;
                        daysToReachGoal = 1; // Need to do it today
                     }

                     // Build forecast string using i18n keys and placeholders
                      const neededText = i18n.t('dashboardForecastNeeded',
                           { remainingHours: formatHoursExtensive(remainingHours) }, // Placeholder for hours left
                           `Need ${formatHoursExtensive(remainingHours)} more.`); // Default text
                       // Use singular/plural keys for days based on 'daysNeeded' count
                       const daysUnit = i18n.t(daysToReachGoal === 1 ? 'daySingular' : 'daysPlural', {}, daysToReachGoal === 1 ? 'day' : 'days');
                     const suggestion = i18n.t('dashboardForecastSuggestion', {
                          avgNeeded: formatHoursExtensive(avgNeeded, true), // e.g., "1.5h"
                          daysNeeded: daysToReachGoal, // e.g., "5"
                          daysUnit: daysUnit, // e.g., "days"
                       }, `~${formatHoursExtensive(avgNeeded, true)} / ${daysUnit} over ${daysToReachGoal} ${daysUnit}.`); // Default text


                      // Combine into HTML, ensuring structure is respected if translation contains HTML
                     forecastText = `<span>${forecastLabelSpan}${neededText}</span><span>${suggestion}</span>`;
                 }
                dashboardForecast.innerHTML = forecastText; // Use innerHTML as forecastText can contain spans

                 updateDashboardPlannedDates(); // Update upcoming plans display
            }


            function updateProgressRing(currentValue, maxValue) {
                if (!progressRingFg || isNaN(progressRingCircumference) || progressRingCircumference <= 0) {
                     console.warn("Cannot update progress ring: element or circumference invalid.");
                     return;
                 }
                const percentage = maxValue > 0 ? Math.min(100, (currentValue / maxValue) * 100) : 0;
                 // Calculate the stroke-dashoffset. 100% = offset 0. 0% = offset circumference.
                const offset = progressRingCircumference * (1 - percentage / 100);
                 progressRingFg.style.strokeDasharray = `${progressRingCircumference} ${progressRingCircumference}`;
                 progressRingFg.style.strokeDashoffset = Math.max(0, offset); // Ensure offset isn't negative
            }


             function updateDashboardPlannedDates() {
                 const today = new Date(); today.setHours(0, 0, 0, 0);
                 const todayStr = getCurrentDateString();
                 const now = new Date();
                 const currentHour = now.getHours();
                 const overdueThreshold = 18; // 6 PM - consider plans for today overdue after this hour

                 // Get future plans (today or later)
                 const futurePlans = plannedEntries
                    .filter(p => p.date >= todayStr)
                     .sort((a,b) => new Date(a.date + 'T00:00:00') - new Date(b.date + 'T00:00:00'));

                  // Get past uncompleted plans, including those for today that are now 'overdue' based on time
                  const pastUncompletedPlans = plannedEntries
                    .filter(p => {
                        const planDate = new Date(p.date + 'T00:00:00');
                         return planDate < today || // Strictly before today
                                (planDate.getTime() === today.getTime() && currentHour >= overdueThreshold); // Or is today, but after the threshold hour
                     })
                     .sort((a, b) => new Date(a.date + 'T00:00:00') - new Date(b.date + 'T00:00:00')); // Sort past plans too


                  // Combine, remove duplicates (if any edge cases caused overlap), sort by date, take top 3
                 const displayPlans = [...futurePlans, ...pastUncompletedPlans]
                    // Reduce to unique plans by ID, prioritizing future ones if somehow duplicated
                     .reduce((acc, current) => {
                         if (!acc.some(item => item.id === current.id)) { acc.push(current); }
                         return acc;
                    }, [])
                    .sort((a, b) => new Date(a.date + 'T00:00:00') - new Date(b.date + 'T00:00:00')) // Final sort
                     .slice(0, 3); // Limit display

                dashboardPlanList.innerHTML = ''; // Clear previous list

                if (displayPlans.length > 0) {
                    dashboardPlannedDatesContainer.classList.remove('hidden'); // Show the container
                    displayPlans.forEach(plan => {
                         const li = document.createElement('li');
                         li.dataset.id = plan.id;
                         const planDate = new Date(plan.date + 'T00:00:00');

                        // Determine if the plan is considered overdue for display purposes
                         const isOverdue = planDate < today || (planDate.getTime() === today.getTime() && currentHour >= overdueThreshold);

                          // Build list item text using i18n placeholders
                         li.innerHTML = i18n.t('dashboardPlannedDateEntry', {
                              relativeDate: formatRelativeDate(plan.date), // e.g., "Tomorrow"
                              hours: formatHoursExtensive(plan.hours, true) // e.g., "2h 30m"
                          }, `<strong>${formatRelativeDate(plan.date)}:</strong> ${formatHoursExtensive(plan.hours, true)}`); // Default format

                        // Add an overdue warning if applicable
                         if (isOverdue) {
                            const warningSpan = document.createElement('span');
                            // Use i18n for the warning text
                            warningSpan.textContent = i18n.t('dashboardPlannedOverdue', {}, ' (Overdue)');
                             warningSpan.classList.add('plan-warning'); // Style appropriately
                            li.appendChild(warningSpan);
                        }
                        dashboardPlanList.appendChild(li);
                     });
                 } else {
                     dashboardPlannedDatesContainer.classList.add('hidden'); // Hide if no plans to show
                 }
             }

             function renderHistory() {
                 historyList.innerHTML = ''; // Clear previous results
                 const searchTerm = historySearchInput.value.trim().toLowerCase();
                 let results = [];
                 let resultsLabelText = '';
                 const hasSearch = searchTerm.length > 0;
                 const defaultTag = getDefaultTag(); // Get potentially translated default tag

                if (hasSearch) {
                    // Filter based on search term across multiple fields
                    results = recordedEntries.filter(entry => {
                         const entryDateFormatted = formatDisplayDate(entry.date).toLowerCase(); // DD/MM/YYYY
                         const entryDateISO = entry.date.toLowerCase(); // YYYY-MM-DD
                         const entryHoursStr = String(entry.hours || 0).replace('.', ','); // Search '1,5' if user types comma
                         const entryHoursRounded = Math.round(entry.hours || 0).toString(); // Search '2' if user types 2 for 1.5h
                         const entryHoursFormatted = formatHoursExtensive(entry.hours).toLowerCase(); // Search "1 hour 30 min"
                         const entryTag = (entry.tag || '').toLowerCase();
                         const entryNotes = (entry.notes || '').toLowerCase();

                         return entryDateFormatted.includes(searchTerm) ||
                                entryDateISO.includes(searchTerm) ||
                                entryHoursStr.includes(searchTerm) ||
                                entryHoursRounded.includes(searchTerm) ||
                                entryHoursFormatted.includes(searchTerm) ||
                                entryTag.includes(searchTerm) ||
                                entryNotes.includes(searchTerm);
                     });

                    // Create label using i18n, e.g., "Showing {count} results for '{term}'"
                     const searchTermText = i18n.t('historyShowingResultsTerm', { term: searchTerm }, ` for "${searchTerm}"`);
                     resultsLabelText = i18n.t('historyShowingResultsLabel', { count: results.length, searchTerm: searchTermText }, `Showing ${results.length} results${searchTermText}`);
                 } else {
                     // No search term: Show recent history (e.g., last 3 months)
                     const dateLimit = getDateMonthsAgo(HISTORY_MONTH_LIMIT);
                     results = recordedEntries.filter(entry => entry.date >= dateLimit);

                     // Set label based on whether recent data exists
                     if (recordedEntries.length > 0 && results.length === 0) {
                          // Have data overall, but nothing recent
                           resultsLabelText = i18n.t('historyNoRecentData', { months: HISTORY_MONTH_LIMIT }, `No records in the last ${HISTORY_MONTH_LIMIT} months.`);
                      } else if (recordedEntries.length > 0) {
                          // Showing recent data
                          resultsLabelText = i18n.t('historyShowingLastMonthsLabel', { months: HISTORY_MONTH_LIMIT }, `Showing last ${HISTORY_MONTH_LIMIT} months`);
                      } else {
                          // No data at all
                           resultsLabelText = ''; // Label handled by placeholder
                      }
                 }

                showingResultsLabel.textContent = resultsLabelText; // Update the results label span

                 // Handle placeholder visibility and text
                 if (results.length === 0) {
                    let placeholderKey = 'historyNoRecordsYet'; // Default if no entries ever
                     if (recordedEntries.length > 0) {
                        // If entries exist, but no results, choose placeholder based on search
                        placeholderKey = hasSearch ? 'historyPlaceholderSearch' : 'historyPlaceholderRecent';
                     }
                     // Set placeholder text using i18n
                     historyListPlaceholder.textContent = i18n.t(placeholderKey, { months: HISTORY_MONTH_LIMIT }, 'No records found.'); // Provide default
                     historyListPlaceholder.classList.remove('hidden');
                 } else {
                     historyListPlaceholder.classList.add('hidden'); // Hide placeholder if results exist
                 }

                 // Render the results
                 results.forEach(entry => {
                     const li = document.createElement('li');
                     li.dataset.id = entry.id; // Store ID for actions

                     // Tag display: Show badge only if tag exists and is not the default one
                    const tagDisplay = entry.tag && entry.tag !== defaultTag
                        ? `<span class="tag-badge">${entry.tag}</span>` // Show the tag
                        : ''; // Empty string if no tag or default tag

                     // Notes display: show preview or a 'no notes' message
                    const notesPreviewText = entry.notes
                         ? entry.notes.replace(/\n/g, ' ') // Replace newlines with spaces for preview
                        : i18n.t('historyEntryNoNotes', {}, '(No notes)'); // i18n for no notes message
                     const notesPreviewClass = entry.notes ? "notes-preview" : "notes-preview no-notes"; // Add class if no notes for potential styling
                     const notesPreview = `<span class="${notesPreviewClass}">${notesPreviewText}</span>`;

                      const hoursDisplay = formatHoursExtensive(entry.hours); // Format hours using i18n

                     // Construct inner HTML of the list item
                      li.innerHTML = `
                         <div class="entry-details">
                             <strong>${formatDisplayDate(entry.date)}:</strong>
                             <span class="hours">${hoursDisplay}</span>
                            ${tagDisplay}
                             ${notesPreview}
                         </div>
                         <div class="entry-actions">
                             <button class="edit-btn secondary" data-translate-key="historyEditButton">${i18n.t('historyEditButton', {}, 'Edit')}</button>
                            <button class="delete-btn danger" data-translate-key="historyDeleteButton">${i18n.t('historyDeleteButton', {}, 'Delete')}</button>
                         </div>`;

                     // Add event listeners for edit/delete buttons within this item
                      li.querySelector('.edit-btn').addEventListener('click', (e) => {
                         e.stopPropagation(); // Prevent li click event if any
                         editRecordEntry(entry.id);
                     });
                     li.querySelector('.delete-btn').addEventListener('click', (e) => {
                         e.stopPropagation();
                         deleteRecordEntry(entry.id);
                     });

                    historyList.appendChild(li); // Add the new item to the list
                 });
             }

            function renderPlanning() {
                 planningList.innerHTML = ''; // Clear previous list
                 const todayStr = getCurrentDateString();

                // Get all plans and sort them by date ascending
                 const allPlansSorted = [...plannedEntries].sort((a, b) => new Date(a.date + 'T00:00:00') - new Date(b.date + 'T00:00:00'));

                // Handle placeholder if no plans exist
                if (allPlansSorted.length === 0) {
                     // Use i18n for the placeholder text
                    planningListPlaceholder.textContent = i18n.t('planningListPlaceholder', {}, 'No future plans.'); // Assuming key covers empty state
                    planningListPlaceholder.classList.remove('hidden');
                    return; // Exit if no plans
                }
                planningListPlaceholder.classList.add('hidden'); // Hide placeholder if plans exist

                 // Render each plan
                 allPlansSorted.forEach(plan => {
                     const li = document.createElement('li');
                     li.dataset.id = plan.id;
                     const hoursDisplay = formatHoursExtensive(plan.hours); // Format hours using i18n
                    const isPastPlan = plan.date < todayStr; // Check if the plan date is before today

                     // Construct inner HTML using i18n for labels and relative dates
                     li.innerHTML = `
                         <div class="entry-details">
                             <strong>${formatDisplayDate(plan.date)} (${formatRelativeDate(plan.date)}):</strong>
                            <span class="hours">${hoursDisplay}</span>
                            <span data-translate-key="planningEntryLabel">${i18n.t('planningEntryLabel', {}, '')}</span> <!-- Optional Label like ' planned' -->
                            ${isPastPlan ? `<span class="plan-past-date-indicator" data-translate-key="planningEntryPastDate">${i18n.t('planningEntryPastDate', {}, '(Past)')}</span>` : ''}
                         </div>
                         <div class="plan-actions">
                             <button class="done-plan-btn success" data-translate-key="planningDoneButton">${i18n.t('planningDoneButton', {}, 'Done')}</button>
                            <button class="delete-plan-btn danger" data-translate-key="planningDeleteButton">${i18n.t('planningDeleteButton', {}, 'Delete')}</button>
                        </div>`;

                     // Add event listeners for 'Done' and 'Delete' buttons
                     li.querySelector('.done-plan-btn').addEventListener('click', (e) => {
                         e.stopPropagation();
                         markPlanAsDone(plan.id); // Call function to move plan to records
                     });
                     li.querySelector('.delete-plan-btn').addEventListener('click', (e) => {
                         e.stopPropagation();
                         deletePlanEntry(plan.id); // Call function to delete the plan
                     });

                     planningList.appendChild(li); // Add the item to the list
                 });
             }

            function updateStatistics() {
                 const currentMonth = new Date().getMonth();
                 const currentYear = new Date().getFullYear();

                 // Filter entries for the current month and year
                 const entriesThisMonth = recordedEntries.filter(entry => {
                     const entryDate = new Date(entry.date + 'T00:00:00');
                     return entryDate.getMonth() === currentMonth && entryDate.getFullYear() === currentYear;
                 });

                let totalHoursThisMonth = 0;
                 const activeDaysThisMonth = new Set(); // Use a Set to count unique days with entries

                 // Calculate totals and gather active days
                 entriesThisMonth.forEach(entry => {
                     totalHoursThisMonth += entry.hours;
                     activeDaysThisMonth.add(entry.date); // Add date string YYYY-MM-DD
                 });

                const goal = settings.monthlyGoal;
                // Calculate progress percentage, handle goal not set case
                 const progressPercentage = settings.goalHasBeenSet
                     ? (goal > 0 ? Math.min(Math.round((totalHoursThisMonth / goal) * 100), 100) : 0)
                     : 0; // Show 0% if goal hasn't been set

                 // Calculate average hours per active day
                 const averageHoursPerActiveDay = activeDaysThisMonth.size > 0
                    ? (totalHoursThisMonth / activeDaysThisMonth.size)
                     : 0;

                 const daysActiveCount = activeDaysThisMonth.size; // Number of unique days with records

                 // Update DOM elements
                statsMonthHours.textContent = formatHoursExtensive(totalHoursThisMonth); // Format total hours
                 // Show percentage or '--%' if goal not set
                 statsMonthGoalProgress.textContent = settings.goalHasBeenSet ? `${progressPercentage}%` : '--%';
                statsMonthProgressBar.style.width = `${progressPercentage}%`; // Update progress bar width
                statsAvgHoursDay.textContent = formatHoursExtensive(averageHoursPerActiveDay); // Format average hours
                 statsMonthDaysActive.textContent = daysActiveCount; // Display number of active days
             }

             function populateMonthSelector() {
                 const availableMonths = new Set(); // Use Set to get unique month-year strings
                 recordedEntries.forEach(e => availableMonths.add(getMonthYearString(new Date(e.date + 'T00:00:00'))));

                 // Convert Set to array and sort descending by date (most recent first)
                 const sortedMonths = Array.from(availableMonths).sort((a, b) => {
                     const [mA, yA] = a.split('/');
                     const [mB, yB] = b.split('/');
                     return new Date(yB, mB - 1) - new Date(yA, mA - 1); // Compare as dates
                 });

                 const oldSelectedValue = chartMonthSelector.value; // Preserve selection if possible
                 chartMonthSelector.innerHTML = ''; // Clear existing options

                 // Handle case where there's no data at all
                 if (sortedMonths.length === 0) {
                    const option = document.createElement('option');
                    option.value = '';
                     option.textContent = i18n.t('chartNoData', {}, 'No data available'); // Use i18n
                     chartMonthSelector.appendChild(option);
                     chartMonthSelector.disabled = true;
                     return; // Exit
                 }

                 chartMonthSelector.disabled = false; // Enable selector if data exists

                 // Get current month/year to potentially add it if missing and mark as '(Current)'
                 const currentMonthYearValue = getMonthYearString(new Date());
                 const currentMonthYearFormatted = formatMonthYearExtensive(currentMonthYearValue); // Format e.g., "July 2024"
                 let hasCurrentMonthInData = sortedMonths.includes(currentMonthYearValue);
                let didSelectOld = false; // Flag to track if the previous selection was restored

                 // Populate options from sorted data
                 sortedMonths.forEach(monthYearValue => {
                     const option = document.createElement('option');
                     option.value = monthYearValue; // Value is "MM/YYYY"
                     // Use i18n function to format display text "Month YYYY"
                      option.textContent = formatMonthYearExtensive(monthYearValue);

                     // Try to re-select the previously selected month
                      if (monthYearValue === oldSelectedValue) {
                          option.selected = true;
                         didSelectOld = true;
                      }
                     // Select current month by default if old value wasn't found or didn't exist
                       else if (monthYearValue === currentMonthYearValue && !didSelectOld) {
                           option.selected = true;
                      }
                     chartMonthSelector.appendChild(option);
                 });

                 // If the current month has no data, add it to the top of the list
                 if (!hasCurrentMonthInData) {
                     const option = document.createElement('option');
                     option.value = currentMonthYearValue;
                      // Add indication like "(Current Month)" using i18n
                     option.textContent = `${currentMonthYearFormatted} ${i18n.t('chartCurrentMonthIndicator', {}, '(Current)')}`;
                    chartMonthSelector.insertBefore(option, chartMonthSelector.firstChild); // Add to the beginning

                    // Select this current month option if no other selection was made
                     if (!didSelectOld && !chartMonthSelector.querySelector('option[selected]')) {
                        option.selected = true;
                    }
                 }

                 // Ensure *something* is selected if options exist
                 if (!chartMonthSelector.value && chartMonthSelector.options.length > 0) {
                     chartMonthSelector.options[0].selected = true;
                 }
             }

             function getAveragesForChart(year, monthIndex) {
                  // Filter entries for the specific year first for efficiency
                  const entriesThisYear = recordedEntries.filter(e => new Date(e.date + 'T00:00:00').getFullYear() === year);

                 // Filter year's entries for the specific month
                  const entriesThisMonth = entriesThisYear.filter(e => new Date(e.date + 'T00:00:00').getMonth() === monthIndex);

                 let totalHoursMonth = 0;
                  const activeDaysMonth = new Set(); // Unique days with records in the selected month
                  entriesThisMonth.forEach(e => {
                     totalHoursMonth += e.hours;
                      activeDaysMonth.add(e.date); // Add date string (YYYY-MM-DD)
                 });

                  // Calculate overall year average based on active months in that year
                  let totalHoursYear = 0;
                 const monthsWithActivityYear = new Set(); // Unique months (MM/YYYY) with records in the selected year
                  entriesThisYear.forEach(e => {
                     totalHoursYear += e.hours;
                      monthsWithActivityYear.add(getMonthYearString(new Date(e.date + 'T00:00:00')));
                  });

                 const daysInMonth = new Date(year, monthIndex + 1, 0).getDate(); // Get number of days in the selected month

                 return {
                      // Average hours per day *that had activity* in this specific month
                     avgDaily: activeDaysMonth.size > 0 ? totalHoursMonth / activeDaysMonth.size : 0,
                      // Estimated average weekly hours *based on the monthly total* for this month
                     avgWeekly: daysInMonth >= 7 && totalHoursMonth > 0 ? (totalHoursMonth / daysInMonth) * 7 : 0,
                      // Average hours per month *across all months that had activity in this specific year*
                     avgMonthly: monthsWithActivityYear.size > 0 ? totalHoursYear / monthsWithActivityYear.size : 0
                 };
             }

             function renderCharts(selectedMonthYearValue) {
                 const ctx = monthlyHoursChartCtx;
                 if (!ctx) { console.error("Chart canvas context not found!"); return; }

                 // Handle case where no month is selected (e.g., initial load before selection)
                 if (!selectedMonthYearValue) {
                     if (monthlyHoursChartInstance) monthlyHoursChartInstance.destroy(); // Clear previous chart
                     monthlyHoursChartInstance = null;
                      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); // Clear canvas
                      ctx.save();
                     ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                      ctx.fillStyle = textMutedColor; ctx.font = `14px ${computedStyles.fontFamily}`;
                      // Use i18n for the message
                      ctx.fillText(i18n.t('feedbackChartSelectMonth', {}, 'Select a month to view the chart'), ctx.canvas.width / 2, ctx.canvas.height / 2);
                     ctx.restore();
                     return;
                 }

                 try {
                     // Parse selected month/year
                     const selectedMonthYearFormatted = formatMonthYearExtensive(selectedMonthYearValue); // e.g., "July 2024"
                     const [selectedMonth, selectedYear] = selectedMonthYearValue.split('/').map(Number);
                     const monthIndex = selectedMonth - 1; // 0-based index for Date object
                     const year = selectedYear;

                     // Filter data for the selected month
                      const entriesSelectedMonth = recordedEntries.filter(e => {
                         const d=new Date(e.date+'T00:00:00'); // Ensure consistency with time
                         return d.getMonth()===monthIndex && d.getFullYear()===year;
                      });

                     const daysInSelectedMonth = new Date(year, monthIndex + 1, 0).getDate(); // Get days in month (handles leap years)

                     // Prepare data array for the chart (one entry per day)
                     const dailyHoursData = Array(daysInSelectedMonth).fill(0);
                     entriesSelectedMonth.forEach(e => {
                          // Date objects are 1-based for day, array is 0-based
                          dailyHoursData[new Date(e.date+'T00:00:00').getDate()-1] += e.hours;
                     });

                      const chartLabels = Array.from({ length: daysInSelectedMonth }, (_, i) => i + 1); // Labels 1, 2, 3...

                     // Calculate averages for annotation lines
                      const averages = getAveragesForChart(year, monthIndex);
                     const annotations = {}; // Object to hold annotation definitions
                      let pluginOptions = {}; // Chart.js plugins configuration

                      // --- Configure Annotations (if plugin is loaded) ---
                      // Check if the annotation plugin is available globally
                     if (window.ChartAnnotation) {
                         // Add annotation line for Average Daily hours (on active days)
                         if (averages.avgDaily > 0) {
                              annotations.avgDay = {
                                 type: 'line', scaleID: 'y', value: averages.avgDaily,
                                 borderColor: avgLineColor1, borderWidth: 1.5, borderDash: [6, 6], // Dashed line
                                 label: {
                                      // Use i18n for label text, e.g., "Avg Daily: {value}"
                                     content: i18n.t('chartAvgDailyLabel', {value:formatHoursExtensive(averages.avgDaily,true)}, `Avg Daily: ${formatHoursExtensive(averages.avgDaily,true)}`),
                                      display: true, position: 'end', color: avgLineColor1, backgroundColor: tooltipBgColor, // Use theme colors
                                     font: { size: 9 }, yAdjust: -10 // Position adjustment
                                 }
                              };
                          }
                          // Add annotation line for Estimated Weekly Average
                          if (averages.avgWeekly > 0) {
                             annotations.avgWeek = {
                                 type: 'line', scaleID: 'y', value: averages.avgWeekly,
                                 borderColor: avgLineColor2, borderWidth: 1.5, borderDash: [10, 10],
                                 label: {
                                     content: i18n.t('chartAvgWeeklyLabel', {value:formatHoursExtensive(averages.avgWeekly,true)}, `Avg Wkly: ${formatHoursExtensive(averages.avgWeekly,true)}`),
                                     display: true, position: 'end', color: avgLineColor2, backgroundColor: tooltipBgColor,
                                     font: { size: 9 }, yAdjust: 2
                                 }
                              };
                         }
                         // Add annotation line for Yearly Monthly Average
                         if (averages.avgMonthly > 0) {
                             annotations.avgMonth = {
                                 type: 'line', scaleID: 'y', value: averages.avgMonthly,
                                 borderColor: avgLineColor3, borderWidth: 1.5, borderDash: [2, 2],
                                 label: {
                                      content: i18n.t('chartAvgMonthlyLabel', {value:formatHoursExtensive(averages.avgMonthly,true)}, `Avg Mthly: ${formatHoursExtensive(averages.avgMonthly,true)}`),
                                     display: true, position: 'end', color: avgLineColor3, backgroundColor: tooltipBgColor,
                                      font: { size: 9 }, yAdjust: 14
                                  }
                             };
                          }
                         // Assign annotations to chart options
                         pluginOptions.annotation = {
                            drawTime: 'afterDatasetsDraw', // Draw lines on top of bars
                             annotations: annotations
                         };
                      } else {
                           console.warn("ChartAnnotation plugin not loaded, average lines will not be displayed.");
                     }


                     // --- Create or Update Chart Instance ---
                     if (monthlyHoursChartInstance) {
                         monthlyHoursChartInstance.destroy(); // Destroy previous instance before creating new
                     }

                    monthlyHoursChartInstance = new Chart(ctx, {
                         type: 'bar',
                         data: {
                             labels: chartLabels,
                             datasets: [{
                                 // Use i18n for dataset label
                                 label: i18n.t('chartDailyHoursLabel', {}, 'Daily Hours'),
                                 data: dailyHoursData,
                                 backgroundColor: primaryColor,
                                 borderColor: primaryColor, // Might not be visible for bars unless width > 0
                                 borderWidth: 0, // No border on bars
                                 borderRadius: 4 // Slightly rounded corners for bars
                              }]
                         },
                         options: {
                              responsive: true,
                             maintainAspectRatio: false, // Important for canvas resizing within container
                              scales: {
                                  y: {
                                      beginAtZero: true,
                                     title:{display:false}, // No Y-axis title needed
                                      ticks:{
                                         color: textMutedColor, // Use theme color
                                          padding: 10,
                                          // Format Y-axis labels (e.g., "1h", "2h 30m")
                                         callback: v => formatHoursExtensive(v, true) // Use short format
                                      },
                                     grid: {
                                          color:gridColor, // Use theme grid color
                                         drawBorder: false // Hide axis border line
                                      }
                                 },
                                 x: {
                                     title:{display:false}, // No X-axis title
                                     ticks:{color:textMutedColor}, // Theme color for day numbers
                                     grid:{display: false} // No vertical grid lines
                                  }
                              },
                             plugins: {
                                  ...pluginOptions, // Include annotation plugin options if available
                                 title: { // Chart Title (Month Name)
                                      display: true,
                                      text: selectedMonthYearFormatted, // e.g., "July 2024"
                                     color: textColor,
                                      font: { size: 14, weight: 'normal' },
                                      padding: { bottom: 15 } // Space below title
                                 },
                                 tooltip: { // Tooltip customization
                                      backgroundColor: tooltipBgColor,
                                     titleColor: textColor,
                                      bodyColor: textColor,
                                      displayColors: false, // Hide the color box in tooltip
                                      padding: 10,
                                      cornerRadius: 6,
                                     callbacks: {
                                          // Customize tooltip text using i18n
                                          label: context => i18n.t('chartTooltipLabel', {
                                                 day: context.label, // Day number
                                                 hours: formatHoursExtensive(context.parsed.y) // Formatted hours
                                              }, `Day ${context.label}: ${formatHoursExtensive(context.parsed.y)}`) // Default text
                                     }
                                  },
                                 legend: { display: false } // Hide the dataset legend
                             }
                         }
                    });
                } catch (error) {
                    console.error("Chart rendering error:", error);
                     if (monthlyHoursChartInstance) monthlyHoursChartInstance.destroy(); // Cleanup failed chart
                    monthlyHoursChartInstance = null;
                    // Display error message on canvas using i18n
                      ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height);
                     ctx.save();
                      ctx.textAlign='center'; ctx.textBaseline='middle';
                     ctx.fillStyle=textMutedColor; ctx.font=`14px ${computedStyles.fontFamily}`;
                     ctx.fillText(i18n.t('feedbackChartRenderError', {}, 'Error rendering chart'), ctx.canvas.width/2, ctx.canvas.height/2);
                     ctx.restore();
                }
             }

             // Central function to update all parts of the UI that depend on data
             function updateAllDisplays() {
                 // Core data updates
                 updateDashboard();
                 updateStatistics();

                 // Update dynamic lists/selectors
                 populateMonthSelector(); // Must run before renderCharts usually
                 renderHistory();
                 renderPlanning();

                 // Chart Rendering Logic - needs careful handling based on selection and data availability
                 const selectedMonthValue = chartMonthSelector.value;
                 let chartRendered = false; // Flag to track if chart was successfully rendered
                  let clearChartMsgKey = 'feedbackChartSelectMonth'; // Default message if chart is cleared

                 if (recordedEntries.length === 0) {
                      // No data exists anywhere
                      clearChartMsgKey = 'feedbackChartNoDataYet';
                 } else if (selectedMonthValue) {
                     // Check if the selected month actually has data
                      const hasData = recordedEntries.some(e => getMonthYearString(new Date(e.date+'T00:00:00')) === selectedMonthValue);
                     if (hasData) {
                          renderCharts(selectedMonthValue); // Render chart for selected month
                          chartRendered = true;
                      } else {
                           // Selected month has no associated entries
                           clearChartMsgKey = 'feedbackChartNoDataMonth';
                      }
                 } else if (chartMonthSelector.options.length > 0 && chartMonthSelector.options[0].value) {
                      // If no specific month is selected, but the selector has options,
                      // try rendering the chart for the *first* (usually most recent) month.
                     const firstMonthValue = chartMonthSelector.options[0].value;
                     chartMonthSelector.options[0].selected = true; // Explicitly select it visually
                     renderCharts(firstMonthValue);
                     chartRendered = true;
                 } else {
                     // This case might occur if populateMonthSelector added a "(Current)" option
                     // with no data, and nothing else was selectable.
                      clearChartMsgKey = 'feedbackChartNoDataYet'; // Or specific message needed?
                  }

                 // Clear the chart canvas if it wasn't rendered successfully
                 if (!chartRendered) {
                     if (monthlyHoursChartInstance) monthlyHoursChartInstance.destroy();
                     monthlyHoursChartInstance = null;
                     const ctx = monthlyHoursChartCtx;
                     if (ctx) { // Ensure context exists before drawing on it
                         ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                         ctx.save();
                          ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                         ctx.fillStyle = textMutedColor; ctx.font = `14px ${computedStyles.fontFamily}`;
                          // Get the appropriate message using i18n key
                          const msg = i18n.t(clearChartMsgKey, { month: formatMonthYearExtensive(selectedMonthValue) }, 'No chart data available.');
                         ctx.fillText(msg, ctx.canvas.width / 2, ctx.canvas.height / 2);
                         ctx.restore();
                     }
                 }

                 // Update Save/Update button text state in record form
                 if (recordIdInput.value) { // If an ID is present, it's in edit mode
                     saveRecordBtn.textContent = i18n.t('updateRecordButton', {}, 'Update Record');
                 } else {
                     saveRecordBtn.textContent = i18n.t('saveRecordButton', {}, 'Save Record');
                 }

                 // Potentially update Plan save button text too if editing is implemented
                 // if (planIdInput.value) { ... }
             }

            // ----- Funções Auxiliares (Inputs, SW, etc) -----
            function formatTimeInputOnType(event) {
                 const input = event.target;
                 let value = input.value;
                 let cursorPos = input.selectionStart; // Store cursor position
                 let numericValue = value.replace(/[^\d]/g, ''); // Get only digits
                 let formattedValue = '';
                 let newCursorPos = cursorPos; // Initialize new cursor position

                 // Limit to max 4 digits (HHMM)
                  numericValue = numericValue.substring(0, 4);

                  if (numericValue.length === 0) {
                     formattedValue = '';
                 } else if (numericValue.length <= 2) { // Handling MM or H format directly as minutes is confusing. Let user type. Assume user means MM. Or HH? Let's assume HH for simplicity if typed without separator. But HH:MM is better.
                     // Let's directly format to HH:MM structure as digits are typed
                      formattedValue = numericValue; // For 1 or 2 digits, keep as is for now? NO. Aim for HH:MM.
                     // This logic is complex on-the-fly. Let's simplify: just ensure HH:MM after blur?
                      // Try simple numeric to HH:MM on the fly
                      if(numericValue.length <= 2) {
                           // User likely entering hours, potentially minutes later
                           formattedValue = numericValue;
                      } else { // 3 or 4 digits
                         const hoursPart = numericValue.slice(0, -2);
                         const minutesPart = numericValue.slice(-2);
                         formattedValue = `${hoursPart}:${minutesPart}`;

                         // Adjust cursor if colon was just added
                         if (value.indexOf(':') === -1 && formattedValue.indexOf(':') !== -1) {
                             // If cursor was at or after where the colon is inserted
                             if (cursorPos >= formattedValue.indexOf(':')) {
                                 newCursorPos = cursorPos + 1;
                             }
                         }
                     }

                 } else { // More than 2 digits, format as H:MM or HH:MM
                     const hoursPart = numericValue.slice(0, -2); // All but last 2
                     const minutesPart = numericValue.slice(-2); // Last 2
                     formattedValue = `${hoursPart}:${minutesPart}`;

                     // Adjust cursor if colon was just added
                      // Check if a colon was newly introduced compared to the original value
                     if (value.indexOf(':') === -1 && formattedValue.indexOf(':') !== -1) {
                          // If the original cursor position was at or after the position where the colon now exists
                         if (cursorPos >= formattedValue.indexOf(':')) {
                             newCursorPos = cursorPos + 1; // Move cursor after the inserted colon
                         }
                      } else if (value.indexOf(':') !== -1 && formattedValue.indexOf(':') === -1) {
                         // If colon was removed (e.g., backspace), adjust cursor backwards if needed
                         if (cursorPos > 0) {
                            // This case needs more complex handling based on where deletion occurred
                             newCursorPos = Math.max(0, cursorPos -1); // Simple approximation
                          }
                      } else if (value.indexOf(':') !== -1 && formattedValue.indexOf(':') !== -1 && value.length > formattedValue.length) {
                        // Digit removed after colon? Needs adjustment.
                         if(cursorPos >= formattedValue.indexOf(':')) newCursorPos = cursorPos // keep same? difficult.
                     } else if (value.indexOf(':') !== -1 && formattedValue.indexOf(':') !== -1 && value.length < formattedValue.length) {
                          // Digit added after colon? Needs adjustment.
                         if(cursorPos >= formattedValue.indexOf(':')) newCursorPos = cursorPos // keep same?
                     }


                 }

                 // Update input value and cursor position only if value changed
                 if (input.value !== formattedValue) {
                     input.value = formattedValue;
                     // Use requestAnimationFrame to ensure cursor is set after potential re-render
                     requestAnimationFrame(() => {
                          input.setSelectionRange(newCursorPos, newCursorPos);
                     });
                 }
             }


            function validateTimeInputOnBlur(event) {
                 const input = event.target;
                 const decimalValue = parseTimeInputToDecimal(input.value);
                 if (!isNaN(decimalValue) && decimalValue > 0) {
                    // Format the valid input into consistent HH:MM
                     input.value = formatDecimalToTimeInput(decimalValue);
                 } else if (input.value.trim() !== '') {
                    // Clear the input if it's invalid and not just empty spaces
                    input.value = '';
                      // Optionally show a brief validation message/feedback
                      // alert(i18n.t('feedbackTimeInvalidOnBlur', {}, 'Invalid time entered. Please use HH:MM format.'));
                 }
            }

            function validateNotesInput(event) {
                 const input = event.target;
                 if (input.value.length > NOTES_MAX_LENGTH) {
                     input.value = input.value.substring(0, NOTES_MAX_LENGTH);
                     // Show feedback using i18n, include the max length
                     showFeedback(i18n.t('feedbackNotesLengthLimit', { maxLength: NOTES_MAX_LENGTH }, `Notes cannot exceed ${NOTES_MAX_LENGTH} characters.`), 'info');
                 }
            }

            function registerServiceWorker() {
                 if ('serviceWorker' in navigator) {
                     navigator.serviceWorker.register('./service-worker.js') // Path relative to origin
                         .then((reg) => {
                             console.log('Service Worker registered successfully. Scope:', reg.scope);
                             // Optional: Add update handling logic here (reg.onupdatefound, etc.)
                         }).catch((error) => {
                            console.error('Service Worker registration failed:', error);
                            // Optionally inform user if offline capabilities might be affected
                             showFeedback(i18n.t('feedbackSWRegisterFailed', {}, 'Offline mode may not be available: Service Worker failed to register.'), 'danger');
                         });
                 } else {
                      console.log('Service Worker not supported by this browser.');
                     // Optionally inform user that offline mode isn't available
                 }
             }

            // ----- Função de Inicialização -----
            async function init() {
                console.log("Initializing Pioneer Work Tracker...");

                // 1. Setup Internationalization
                 i18n.detectLanguage();
                 await i18n.loadTranslations();

                 // 2. Select DOM Elements (assign to global vars)
                console.log("Selecting DOM elements...");
                // Use try-catch or check element existence for robustness? Maybe overkill for this app.
                 appElement=document.getElementById('app');dashboardWeekHours=document.getElementById('dashboard-week-hours');dashboardMonthPercentage=document.getElementById('dashboard-month-percentage');dashboardMonthTotal=document.getElementById('dashboard-month-total');dashboardForecast=document.getElementById('dashboard-forecast');dashboardPlannedDatesContainer=document.getElementById('dashboard-planned-dates');dashboardPlanList=document.getElementById('dashboard-plan-list');progressRingFg=document.getElementById('progress-ring-fg');recordCard=document.getElementById('record-card');recordForm=document.getElementById('record-form');recordIdInput=document.getElementById('record-id');recordDateInput=document.getElementById('record-date');dateLabel=document.getElementById('date-label');displayDate=document.getElementById('display-date');changeDateBtn=document.getElementById('change-date-btn');recordHoursInput=document.getElementById('record-hours');recordTagSelect=document.getElementById('record-tag');recordNotesInput=document.getElementById('record-notes');saveRecordBtn=document.getElementById('save-record-btn');planCard=document.getElementById('plan-card');planForm=document.getElementById('plan-form');planIdInput=document.getElementById('plan-id');planDateInput=document.getElementById('plan-date');planHoursInput=document.getElementById('plan-hours');savePlanBtn=document.getElementById('save-plan-btn');clearPlanFormBtn=document.getElementById('clear-plan-form-btn');planningList=document.getElementById('planning-list');planningListPlaceholder=document.getElementById('planning-list')?.querySelector('.placeholder'); // Safer selection
                monthlyGoalInput=document.getElementById('monthly-goal');saveGoalBtn=document.getElementById('save-goal-btn');statsMonthHours=document.getElementById('stats-month-hours');statsMonthGoalProgress=document.getElementById('stats-month-goal-progress');statsMonthProgressBar=document.getElementById('stats-month-progress-bar');statsAvgHoursDay=document.getElementById('stats-avg-hours-day');statsMonthDaysActive=document.getElementById('stats-month-days-active');chartMonthSelector=document.getElementById('chart-month-selector');monthlyHoursChartCtx=document.getElementById('monthlyHoursChart')?.getContext('2d'); // Check getContext
                historyList=document.getElementById('history-list');historySearchInput=document.getElementById('history-search-input');historyListPlaceholder=document.getElementById('history-list')?.querySelector('.placeholder'); // Safer selection
                showingResultsLabel=document.getElementById('showing-results-label');clearAllDataBtn=document.getElementById('clear-all-data-btn');confirmationDialog=document.getElementById('confirmation-dialog');dialogMessage=document.getElementById('dialog-message');dialogConfirmBtn=document.getElementById('dialog-confirm-btn');dialogCancelBtn=document.getElementById('dialog-cancel-btn');

                // 2b. Get dynamic styles needed for JS (e.g., Chart.js colors)
                computedStyles = getComputedStyle(document.body); // Get styles after CSS is parsed
                textColor = computedStyles.getPropertyValue('--text-color').trim();
                textMutedColor = computedStyles.getPropertyValue('--text-color-secondary').trim();
                gridColor = computedStyles.getPropertyValue('--border-color').trim();
                tooltipBgColor = computedStyles.getPropertyValue('--card-bg').trim(); // Tooltip same bg as cards? Or input?
                primaryColor = computedStyles.getPropertyValue('--primary-color').trim();
                 avgLineColor1 = computedStyles.getPropertyValue('--avg-line-color-1').trim();
                 avgLineColor2 = computedStyles.getPropertyValue('--avg-line-color-2').trim();
                 avgLineColor3 = computedStyles.getPropertyValue('--avg-line-color-3').trim();

                 // 2c. Calculate Progress Ring Circumference (check element exists first)
                 if (progressRingFg && progressRingFg.r && progressRingFg.r.baseVal) {
                     progressRingRadius = progressRingFg.r.baseVal.value;
                     progressRingCircumference = 2 * Math.PI * progressRingRadius;
                      // Initialize ring appearance
                      progressRingFg.style.strokeDasharray = `${progressRingCircumference} ${progressRingCircumference}`;
                      progressRingFg.style.strokeDashoffset = progressRingCircumference; // Start at 0%
                 } else {
                     console.error("Progress ring element or its radius (r.baseVal) not found at init. Ring will not update.");
                     progressRingCircumference = 0; // Prevent NaN errors later
                 }


                 // 3. Apply Initial Translations to static DOM content
                 console.log("Applying initial translations to DOM...");
                 i18n.applyTranslationsToDOM();

                 // 4. Load saved data (Entries, Plans, Settings)
                console.log("Loading data from storage...");
                 loadData(); // This also sanitizes and sorts data

                 // 4b. Data Migration/Cleanup (Example: Update old default tags)
                 const oldDefaultTag = "Casa em casa"; // Hardcoded old value IF it was different previously
                 const currentDefaultTag = getDefaultTag(); // Get current default from i18n
                 if (oldDefaultTag !== currentDefaultTag) {
                     let tagsUpdated = false;
                     recordedEntries.forEach(entry => {
                          // Update if tag is missing or matches the old hardcoded default
                         if (entry.tag === oldDefaultTag || !entry.tag) {
                              entry.tag = currentDefaultTag;
                             tagsUpdated = true;
                         }
                     });
                     if (tagsUpdated) {
                          console.log(`Updating old default tags ('${oldDefaultTag}') to current ('${currentDefaultTag}'). Saving...`);
                          saveData(); // Save changes if any tags were updated
                      }
                 }
                  // Ensure settings input reflects loaded value
                 if(monthlyGoalInput) monthlyGoalInput.value = settings.monthlyGoal;

                 // 5. Register Chart Plugins (if available)
                 if (window.ChartAnnotation) {
                      try { Chart.register(ChartAnnotation); console.log("ChartAnnotation plugin registered."); }
                     catch (e) { console.error("Error registering ChartAnnotation:", e); }
                  } else { console.warn("ChartAnnotation plugin (chartjs-plugin-annotation) not found globally. Average lines disabled."); }

                 // 6. Add Event Listeners
                 console.log("Adding event listeners...");
                // Card Toggling (Event delegation on #app container)
                if (appElement) {
                    appElement.addEventListener('click', (event) => {
                         // Find the closest ancestor header that is clickable
                         const header = event.target.closest('.card-header[role="button"]');
                         // Exclude clicks on buttons/inputs inside the header if any were added
                         if (header && !event.target.closest('button, input, select, textarea, a')) {
                             // Check screen size - only toggle on smaller screens where it's relevant
                             if (window.innerWidth < 992) { // Match the CSS breakpoint
                                 toggleCard(header.closest('.card'));
                             }
                         }
                     });

                    // Accessibility: Allow toggling with Enter/Space on the header
                    appElement.addEventListener('keydown', (event) => {
                        if (window.innerWidth < 992) { // Only active on small screens
                             const header = event.target.closest('.card-header[role="button"]');
                             if (header && (event.key === 'Enter' || event.key === ' ')) {
                                 event.preventDefault(); // Prevent page scroll on Space
                                 toggleCard(header.closest('.card'));
                             }
                         }
                    });
                } else { console.error("#app element not found for event listeners."); }


                // Record Form Listeners
                 if(changeDateBtn) changeDateBtn.addEventListener('click', () => setDateInputVisibility(true));
                if(recordHoursInput) {
                     recordHoursInput.addEventListener('input', formatTimeInputOnType);
                     recordHoursInput.addEventListener('blur', validateTimeInputOnBlur);
                 }
                if(recordNotesInput) recordNotesInput.addEventListener('input', validateNotesInput);
                if(recordForm) recordForm.addEventListener('submit', handleRecordSubmit);

                // Plan Form Listeners
                if(planHoursInput) {
                    planHoursInput.addEventListener('input', formatTimeInputOnType);
                    planHoursInput.addEventListener('blur', validateTimeInputOnBlur);
                 }
                 if(planForm) planForm.addEventListener('submit', handlePlanSubmit);
                 if(clearPlanFormBtn) clearPlanFormBtn.addEventListener('click', clearPlanForm);

                 // Settings/Stats Listeners
                 if(saveGoalBtn) saveGoalBtn.addEventListener('click', handleGoalSave);
                if(monthlyGoalInput) monthlyGoalInput.addEventListener('keypress', (e)=>{
                     if(e.key === 'Enter'){ e.preventDefault(); handleGoalSave(); monthlyGoalInput.blur(); } // Save on Enter key
                });
                 if(clearAllDataBtn) clearAllDataBtn.addEventListener('click', handleClearAllData);

                 // History & Chart Listeners
                if(historySearchInput) historySearchInput.addEventListener('input', () => renderHistory()); // Use throttle/debounce later if needed
                 if(chartMonthSelector) chartMonthSelector.addEventListener('change', () => updateAllDisplays()); // Render chart for new month

                // Dialog Listeners
                if(dialogConfirmBtn) dialogConfirmBtn.addEventListener('click', () => {
                     try {if(typeof currentConfirmCallback === 'function') currentConfirmCallback();} // Execute stored callback
                     catch(e){console.error("Error in confirmation callback:", e);}
                    finally {hideConfirmationDialog();} // Always hide dialog
                 });
                 if(dialogCancelBtn) dialogCancelBtn.addEventListener('click', hideConfirmationDialog);
                if(confirmationDialog) confirmationDialog.addEventListener('click', (e)=>{
                     // Hide if backdrop is clicked directly
                    if(e.target === confirmationDialog) hideConfirmationDialog();
                });

                 // PWA Installation Listener
                window.addEventListener('beforeinstallprompt', (e)=>{
                     console.log('`beforeinstallprompt` event fired.');
                    // Prevent the mini-infobar from appearing on mobile
                    e.preventDefault();
                    // Stash the event so it can be triggered later.
                    deferredInstallPrompt=e;
                    // Optionally, update UI to show a custom install button
                    // showInstallPromotion();
                 });

                // 7. Set Initial UI State
                 console.log("Setting initial UI state...");
                 if (recordDateInput) recordDateInput.value = getCurrentDateString();
                setDateInputVisibility(false); // Show "Today" initially
                 clearRecordForm(); // Ensure forms are clear on load
                 clearPlanForm();
                // Set initial card expansion based on screen size? No, CSS handles default desktop expansion.
                 // Let CSS handle initial 'expanded' state on mobile for record-card if desired.
                /* If record-card should start collapsed on mobile, remove 'expanded' from its HTML class attribute.
                document.querySelectorAll('.card').forEach(card => {
                    const shouldBeExpandedMobile = (card.id === 'record-card'); // Example: only record card starts open
                    if(window.innerWidth < 992) { // Check mobile view
                        if (card.classList.contains('expanded') !== shouldBeExpandedMobile) {
                             toggleCard(card);
                        }
                    } // Desktop state handled by CSS @media query
                 });
                 */

                // 8. Perform Initial Full Display Update (Dashboard, Stats, Lists, Chart)
                 console.log("Performing initial full display update...");
                 updateAllDisplays();

                 // 9. Register Service Worker (for PWA offline capability)
                 registerServiceWorker();

                 // 10. Check if initial setup needed (e.g., prompt for goal)
                if (!settings.goalHasBeenSet) {
                     console.log("Initial goal not set, prompting user...");
                     // Delay prompt slightly to allow page render
                     setTimeout(promptForMonthlyGoal, 700);
                 }

                 // 11. Start background tasks/intervals if any (e.g., periodically checking plan dates)
                // Check planned dates every minute to update dashboard if overdue status changes mid-session
                 setInterval(updateDashboardPlannedDates, 60 * 1000); // Every 60 seconds

                console.log("Pioneer Work Tracker Initialization complete.");
             }


             // Global Error Handler (Optional but Recommended)
             window.addEventListener('error', (event) => {
                 console.error('Unhandled global error:', event.error, 'at', event.filename, ':', event.lineno);
                 // Potentially show a user-friendly message or log to a server
                  showFeedback(i18n.t('feedbackUnhandledError', {}, 'An unexpected error occurred. Please refresh the page or contact support if it persists.'), 'danger');
             });
              window.addEventListener('unhandledrejection', (event) => {
                  console.error('Unhandled promise rejection:', event.reason);
                   showFeedback(i18n.t('feedbackUnhandledRejection', {}, 'An unexpected background error occurred.'), 'danger');
             });

            // --- Start the application ---
             init().catch(err => {
                  console.error("Fatal error during application initialization:", err);
                  // Display a critical error message to the user
                  const body = document.body;
                  // Basic error message styling
                 body.innerHTML = `<div style="padding: 20px; text-align: center; color: #ff453a; background-color: #1c1c1e; font-family: var(--system-font, sans-serif); min-height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                    <h2 data-translate-key="initializationErrorTitle">Application Error</h2>
                     <p data-translate-key="initializationErrorMessage">Could not initialize the application. Please try refreshing the page. If the problem persists, data might be corrupted.</p>
                     <pre style="font-size: 0.8em; color: #ccc; text-align: left; white-space: pre-wrap; max-width: 80%; overflow: auto; background-color: #333; padding: 10px; border-radius: 5px; margin-top: 15px;">${err.message}\n${err.stack}</pre>
                     </div>`;
                 // Try to apply translation to the error message itself, though i18n might have failed
                 try { i18n.applyTranslationsToDOM(); } catch(e) {}
             });

        });
    </script>
</body>
</html>
